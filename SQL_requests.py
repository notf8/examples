Базы данных бывают реляционными и не реляционными
Реляционные (SQL базы - Stucture Query Language = Язык структурированых запросов)- в базе данные связаны между собой
Данные не дублируются, легко вносить измененеия, легко использовать
- Строки - называются записями
- Столбцы - называются полями
Самые популярные базы: MySQL и PostgreSQL MSSQL(майкросовтовская), Oracle(в корпорациях и на java языке), SQLite(мобильная)
========================================================================================================================
Не реляционные = NoSQL. Формат хранения данных:
ключ:значение - (используют для кэширования) Redis, AmazonDynamo
JSON - объект, состоящие из ключей и значений. Ключ - это всегда str. Значение: Any. Они как правило документоориентированы
(MongoDB, CouchDB, Elasticsearch)
========================================================================================================================
Типы полей в реляционных базах в MySQL:
Числовые:
- TINYINT - для целых чисел от -128 до 127 (всего 256 значений)
- INT - так же для целочисленных данных от - 2 млрд до 2 с копейкаи млрд
- BigINT - от -2**63 до 2**63-1
- FLOAT - c плавающей точкой от 1.7 * 10**-38 до 3.4 * 10**38
- DOUBLE - с плавающей точкой в два раза большей точности (чем float) от 2.2 * 10**-308 до 1.8 * 10**308
Дата и время:
- datetime - сохраняется дата и время От 1000 до 9999 (YYYY-MM-DD HH:MM:SS - именно такой формат в базе MySQL)
- date - хранится только дата (YYYY-MM-DD) От 1000 до 9999
- TIMESTAMP - Хранятся числа, отражающие количество секунд (YYYY-MM-DD HH:MM:SS), прошедших с 01.01.1970 Срок с 1970 по 19.01.2038
Строковые:
- CHAR(N) - в скобках указываем длину строки. Макс - 255. Строки будут той длины, что указали (не больше не меньше)
- VARCHAR(N) - в скобках указываем длину Макс - 65535 после 5й версии MySQL и 255 до 5й. Длина строк будет от 0 до указанной
- TUNYTEXT - Макс - 255
- TEXT - Макс - 65565
- MEDIUMTEXT - 16 mb данных
- LONGTEXT - 4 Gb данных (интересно: Геном человека в тестовом виде занимает чуть более 3х Gb)
- ENUM - Можно сохранять набор значений (YES и NO)
- Пространственные - хранят все что связано с пространством
- JSON-данные - можно хранить JSON объекты
========================================================================================================================
Специальное значение NULL - может стоять в поле любого типа, если поле не помечено как 'NOT NULL'
========================================================================================================================
Типы связей в реляционных базах
- Один ко многим (one-to-many)- Например база книг. Один автор может быть связан со многими книгами. Или таблица ссылается на саму себя -
Это означает родительское и дочерней отношение (NULL - означает корневой родитель)
- Один к одному - две таблицы (one-to-one): Страны и Столицы, ссылаются по 1 столбцу (по ID), такое поле помечают как UNIQ
- Многие ко многим (many-to-many)- одна запись из первой таблицы может ссылаться на несколько из второй и наоборот
========================================================================================================================
Дамп базы - типа вся инфа по базе, выгруженная в файл, из которго можно всю базу восстановить
========================================================================================================================
результатом выполнения SELECT-запросов всегда является таблица. Такая таблица может состоять как из нескольких полей и
записей, так и всего из одной записи в одном поле, как в последнем примере. Таблица в результате выполнения запроса может
быть и пустой, если условиям в SELECT-запросе не соответствует ни одна запись.
========================================================================================================================
Типы запросов:
1) Запросы на получение данных - Это всегда запросы с оператором SELECT, с помощью этого оператора можно получить данные
как из одной таблицы так и из нескольких. Можно получать данные по выбраным полям, фильтровать значения по разным условиям
 - Пример запроса: select * from tablename; (вместо звездочки могут быть имена полей, конец запроса всегда точка с запятой)
 - Важно, если с базой работаем через язык програмирования, и делаем только один запрос то ';' в конце запрос можно не писать
 - Имя таблицы записывают в обратные одинарные кавычки (это клавиша - тильда (ё) (что бы экранировать его от имени сервера)
 - Если нужно получить несколько полей, то просто перечисляем их имена в одинарных кавычках после оператора SELECT чероез запятую
 - При запросе полей, можно изменять название полей: SELECT `field_1` as F1 from tabelname; (или просто: SELECT field_1 F1 from tabelname)
 - Так же можно производить арифметические вычисления с полями при запросе: SELECT `name`, (`field_1` * `field_2`) `totalcoast` from tabelname;

2) Фильтрация данных, оператор WHERE:
 - Фильтрация по равенству какому то числу: SELECT `id`, `name` from `good` WHERE `count` = 0 (псле оператора WHERE пишется условие)
- Фильтрация по тексту: SELECT * from `order_status` WHERE `code` != 'NEW' (текст, как обычно оборачиваем в обычные кавычки)
    Важно! Равенство в SQL в отличии от Python, проверяется одни знаком '='
- Фильтрация по датам: SELECT `id`, `name`, `reg_time` from `user` WHERE `reg_date` >= '2019-01-01'
- Фильтрация по диапазону дат/времени: SELECT * from `user` WHERE `reg_date`>= '2019-08-01' and `reg_date`<= '2019-07-01'
    или                                SELECT * from `user` WHERE `reg_date` BETWEEN '2019-08-01' and '2019-07-01' (оператор
                                    BEETWEN позволяет установить диапазон между)
- Фильтрация по строкам с помощью масок:  SELECT * from `goods` WHERE `name` LIKE 'Чай' (Оператор LIKE позволяет добавлять
                                                                                                        в условия маски)
    Маски:
    '_' - Только один символ (любой)
    '%' - От 0 и более символов. Например: '%Чай%'- будет означать, что слово чай может встречаться в любом месте поля
- Фильтрация с масками и енсколько условий: SELECT * from `goods` WHERE `name` LIKE '%Чай%' or '% Чай %' or '% Чай' or 'Чай %'
    Важно! Пробел в масках так же используется, что бы искать слово чай в начале или конце фразы
- Операторы для работы с категориями Null: Их всего два - is Null и is not Null
    Пример: SELECT * from `user` WHERE `parent_id` is not Null;
    Важно! Обычные операции (например равенсто) не работают с Null, только два этих оператора
- Оператор IN: SELECT * from `goods` WHERE `status` IN (7, 8) - так задаем список (несколько условий для поиска, точ бы
   не писать оператор OR)
- Приоритеты опеторов: Как и в питоне(аналогично) SELECT * from `goods` WHERE `name` LIKE ('%Чай%' or '% Чай %' or '% Чай' or 'Чай %') \
                                                                                     and `parent_id` is not Null
    Таким образом, скобками мы объединяем все условие OR в одно, что бы поиск был по приоритету (у and проиоритет выше)
========================================================================================================================
Сортировка и ограничение результатов
 - Сортировка по убыванию/возрастанию: SELECT * from `good` order by `name` ASC (order by - сортировка, ASC - возрастанию
    DESC - убыввание (descending). Что бы сортировать по нескольким полям, просто указываем их через запятую после оператора
    order by: SELECT * from `good` order by `category_id` DESC, `name`  ASC- после каждого поля нужно писать тип сортировки,
    если нуэна сортировка по ворзрастанию, то ASC писать не нужно, т.к. это сортировка по умолчаню
 - Ограничение результатов запроса: SELECT * from `good` order by `price` limit 10, 20
    10 - с какого элемента выдавать результыта, 20 - сколько элементов выдавать по запросу
========================================================================================================================
Объединение таблиц (Join):

Inner Join (внутреннее объединение). При написании такого запроса, слово INNER можно не писать. При таком запросе выводятся
только те записи, данные из которых, есть в обоих таблицах (пересекающиеся данные)
 - SELECT `good_category`.name category_name, `good`.name good_name from `good` join `good_category` on `good_category`.id = `good`.category_id limit 10
    где: после SELECT пишем какие поля вывести, после FROM пишем из какой таблицы выводим поля, а после оператора
    JOIN пишем с какой таблицей надо связать поля, после оператора ON (по какому принципу), указываем как надо связать поля
    К полям обращаемся через точку после названия таблице, то есть как к методу класса
    После названия поля можем сразу переименовать его, просто добавив название сразу через пробел
    А если переименовать таблицы, то запрос получится куда короче, например:
    SELECT
        c.name category_name,
        g.name good_name
    from
        `good` g
    join `good_category` c on
        c.id = g.category_id limit 10
    Важно! Переименование происходит в операторах from и join (то есть в них оставляем настоящие названия таблиц)
Так же существуют LEFT JOIN и RIGHT JOIN. При объединении с помощью LEFT JOIN - из левой таблицы выводятся все записи,
а из правой только те, которые встречаются в левой таблице. Если для какой то записи не будет соотвтетсвия в левой таблице,
то в этом поле мы получим значение NULL. Соотвтетсвенно при объединении RIGHT JOIN все происходит с точностью до наоборот

Объединение нескольких таблиц в одну (с переименованием полей/таблиц) для сокращения запроса
    select
        c.name categotyName,
        g.name productName,
        o.creation_date orderDate,
        u.name userName
    from `good` g
    join good_category c on c.id = g.category_id
    join order2good o2g on o2g.good_id = g.id
    join `order` o on o.id = o2g.order_id and (здесь можно добавить нужное условие для объединения просто через AND)
        o.creation_date between '2017-08-01' and '2017-08-31'
    join `user` u on u.id = o.user_id
