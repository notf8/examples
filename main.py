import fileinput

Применение INT к кривой формуле
# a = '2'
# b = '5'
# c = '3'
# num = 6 ** int(a) + (7 - int(b)) * int(c)
# print(num)

print('Задача 8. Обмен значений двух переменных')
# a = input('Введите первое слово: ')
# b = input('Введите второе слово: ')
# print(a,b)
# a,b = b,a
# print(a,b)

print('Задача 10. Поменять местами: не всё так просто! (необязательная, повышенной сложности)')

# # Мы умеем менять местами строковые переменные и знаем,
# # что в переменных, кроме строк, можно хранить и числа.
# # Напишите программу, которая меняла бы значения двух переменных местами,
# # но без использования третьей переменной и без использования  синтаксического сахара,
# # который мы разбирали, а именно — без конструкции a,b = b,a.
# # В переменные будут вводиться только числа.

# a = int(input('Введите первое число: '))
# b = int(input('Введите второе число: '))
# print(a, b)
# a = a + b
# b = a - b
# a = a - b
# print(a, b)

# # Изменять, удалять, менять местами 10, 11 строку, первый и второй print нельзя.
# # Но между 12-й и 14-й строчкой можно вставлять сколько угодно строк кода, не трогая последний принт.

Деление нацело и с остатком
# apples = int(input('Введите количество яблок: ')) # Например 41
# boxes = int(input('Сколько яблок помещается в ящик: ')) # Например 3
# fullboxes = apples // boxes
# print('Полных ящиков: ', fullboxes)
# apples_left = apples % boxes
# print('Яблок останется: ', apples_left)

Отделение последней цифры (деление на 10, например в задаче цифра 496)
# num = int(input('Введите число: '))
# print('Номер дома: ', num % 10)
# print('Номер квартиры: ', num // 10)

# Пример расчета дистанции не полного круга спортсмена (сколько метров не полного круга пройдено)
# distans = int(input('Введите дистанцию в метрах: '))
# lap = 100
# print('Колличество полных кругов: ', distans // lap)
# print('Дистанция не полного круга: ', distans % lap)

print('Задача 7. Поездка по кругу')
# # Вася решил потренироваться перед марафоном и покататься вокруг Москвы на скорость.
# # Длина дороги — 115 километров.
# # Вася стартует с нулевого километра и едет со скоростью v километров в час.
# # На какой отметке он остановится через t часов?
# #
# # Реализуйте программу,
# # которая спрашивает у пользователя v и t,
# # и выводит целое число от 0 до 114 — номер километра, на котором остановится Вася.
# # Учтите, что он может прокатиться больше одного круга.

# v = int(input('Введите значение скорости (км/ч): '))
# t = int(input('Введите количество часов: '))
# lap_length = 115
# distance = v * t
# print('Номер киллометра остановки:', distance % lap_length)

print('Задача 8. Режем число на части')
# # Реализуйте программу,
# # которая получает на вход четырёхзначное число
# # и выводит на экран каждую его цифру отдельно
# # (в одну строчку либо каждая цифра в новой строчке).
# # Само число при этом изменять нельзя, то есть нужно обойтись без переприсваивания.
# # Однако можно использовать сколько угодно переменных

# num = int(input('Введите четырехзначное число: '))
# char_1 = print(num // 1000)
# char_2 = print(num // 100 % 10)
# char_3 = print(num % 100 // 10)
# char_4 = print(num % 10)

# # Или в строчку:
# num = int(input('Введите четырехзначное число: '))
# char_1 = num // 1000
# char_2 = num // 100 % 10
# char_3 = num % 100 // 10
# char_4 = num % 10
# print(char_1, char_2, char_3, char_4)

print('Задача 9. В обратном порядке')

# Реализуйте программу,
# которая получает на вход четырёхзначное число и выводит его на экран в обратном порядке.
# Само число при этом изменять нельзя, то есть нужно обойтись без переприсваивания.
# Однако можно использовать сколько угодно переменных.
# Пример ввода: 1234.
# Пример вывода: 4321.

# num = int(input('Введите четырехзначное число: '))
# char_1 = num // 1000
# char_2 = num // 100 % 10
# char_3 = num % 100 // 10
# char_4 = num % 10
# backward = char_1 + char_2 * 10 + char_3 * 100 + char_4 * 1000
# print(backward)

Полный опертор if + else
# bank = int(input('Сколько денег на счету '))
# if bank >= 75000:
#   bank -= 75000
#   print('Курс успешно приобритен!')
#   print('Остаток на счету:', bank)
# else:
#   print('Не достаточно средств на счету')
# print('Хорошего дня!')

print('Задача 5. Модуль числа')

# Математик Саша пишет программу, которая должна строить график функции y = |x|.
# Для этого ему нужно находить модуль очередного числа x,
# то есть если число x отрицательное, то переводить его в положительное.
# Напишите программу, которая выводит на экран модуль введённого числа.
#
# Пример:
# Ввели 5, ответ 5
# Ввели −7, ответ 7
#
# Подсказка: достаточно в некоторых случаях переприсвоить переменную со знаком минус.

# num = int(input('Введите число: '))
# if num < 0:
#   print('Ввели', num, 'ответ', - num)
# else:
#   print('Ввели', num, 'ответ', num)
# или усложненная версия
# n = int( input() )
# print("Ввели", n, ", ответ", abs(n))

print('Задача 10. Максимальное число (по желанию)')

# Пользователь вводит три числа.
# Напишите программу,
# которая выводит на экран максимальное из этих трёх чисел (все числа разные).
# Можно использовать дополнительные переменные, если нужно

# num_1 = int(input('Первое число: '))
# num_2 = int(input('Второе число: '))
# num_3 = int(input('Третье число: '))
# if num_1 > num_2:
#   bigger = num_1
# else:
#   bigger = num_2
# if num_3 > bigger:
#   bigger = num_3
# print('Наибольшее число:', bigger)

# Вариант №2
# num_1 = int(input('Первое число: '))
# num_2 = int(input('Второе число: '))
# num_3 = int(input('Третье число: '))
# if (num_1 > num_2) and (num_1 > num_3):
#   print('Максимальное число:', num_1)
# elif (num_2 > num_1) and (num_2 > num_3):
#   print('Максимальное число:', num_2)
# else:
#   print('Максимальное число:', num_3)

# # Этот способ честно нарыл в инете))))
# num_1 = int(input('Первое число: '))
# num_2 = int(input('Второе число: '))
# num_3 = int(input('Третье число: '))
# list = [num_1, num_2, num_3]
# print('Наибольшее число:', max(list))

Последовательная проверка 3 и более чисел (какое больше). Важно обратить внимание на
формат записи (в else вложен if)
# x = int(input('Введите значение X: '))
# y = int(input('Введите значение Y: '))
# if x > y:
#   print('X больше Y')
# else:
#   if x < y:
#     print('X меньше Y')
#   else:
#     print('X равен Y')

Применение elif (обратить внимание на синтаксис. его применяют, если интервалов для проверки 3 и более
print('Задача 9. Прогрессивный налог 2')

# Однако во многих странах,
# использующих такую шкалу, эта сумма вычисляется более сложным способом:
# налоговая ставка 30% на доход выше 50 000 означает,
# что 30% уплачивается не со всей суммы,
# а лишь с той ее части, которая превосходит 50 000.

# Аналогично, ставка 20% на доход от 10 000 до 50 000
# обязывает уплатить 20% лишь с той части суммы,
# которая превосходит 10 000, но не превосходит 50 000.

# Так, например,
# с дохода 100 000 придется заплатить такой налог:
# 30% * (100 000 − 50 000) + 20% * (50 000 − 10 000) + 13% * 10 000 = 15 000 + 8 000 + 1 300  = 24 300.

# А с дохода 30 000 — такой:
# 20% * (30 000 − 10 000) + 13% * 10 000 = 4 000 + 1 300 =  5 300.

# profit = int(input('Введите прибыль: '))
# tax = 1
# tax_1 = tax * 13 / 100
# tax_2 = tax * 20 / 100
# tax_3 = tax * 30 / 100
# if profit <= 10000:
#   tax = profit * tax_1
#   print('Налоговых ставок: 1, Cумма налога:', tax)
# elif profit <= 50000 and profit > 10000:
#   tax = (tax_2 * (30000 - 10000)) + (tax_1 * 10000)
#   print('Налоговых ставок: 2, Cумма налога:', tax)
# else:
#   tax = (tax_3 * (profit - 50000)) + (tax_2 * (50000 - 10000)) + (tax_1 * 10000)
#   print('Налоговых ставок: 3, Cумма налога:', tax)

Определить, сколько совпадений среди 3 чисел.
# Программа должна вывести одно из чисел:
# 3 (если все совпадают),
# 2 (если два совпадает) или 0 (если все числа различны).

# num_1 = int(input('Первое число: '))
# num_2 = int(input('Второе число: '))
# num_3 = int(input('Третье число: '))
# if num_1 == num_2 == num_3:
#   print('Количество совпадений: 3')
# elif num_1 == num_2 or num_2 == num_3 or num_1 == num_3:
#   print('Количество совпадений: 2')
# else:
#   print('Количество совпадений: 0')

print('Задача 10. Почта, рабочие часы')

# Почтовое отделение открывается в 08:00 и закрывается в 22:00.
# С 14:00 до 15:00 все сотрудники уходят на обед,
# а в 10:00 и 18:00 приезжают машины с посылками,
# и тогда все сотрудники на два часа заняты их разгрузкой.
# Во время обеда, разумеется, посылки никто не выдаёт,
# как и в моменты, когда разгружаются машины.

# первый — при выполнении условия выводится сообщение:
# «Можно получить посылку»,

# второй —  при выполнении условия выводится сообщение:
# «Посылку получить нельзя».

# hours = int(input('Введите время: '))
# if (hours >= 8 and hours < 10) or (hours >= 12 and hours < 14) or (hours >= 15 and hours < 18) or (hours >= 20 and hours < 22):
#   print('Можно получить посылку')
# else:
#   print('Посылку получить нельзя')

# hours = int(input('Введите время: '))
# if (hours >= 0 and hours < 8) or (hours >= 10 and hours <= 12) or (hours >= 14 and hours <= 15) or (hours >= 18 and hours <= 20) or (hours >= 22 and hours <= 24):
#   print('Посылку получить нельзя')
# else:
#   print('Можно получить посылку')

Сумирование с циклом (while)
# balance = int(input('Сколько денег на счету: '))
# while balance < 1930000:
#   print('На тачку пока не хватает... ')
#   plus = int(input('Сколько еще денег отложить: '))
#   balance += plus
# print('Ура, Sonata наша!!! Вперед к диллеру')
# print('Денег на счету:', balance)

Использование break с постоянным снижением одной из переменных
# temp = int(input('Какая температура: '))
# dist = 0
# while temp > 15:
#   dist += 20
#   temp -= 2
#   if temp <= 15:
#     break
#   dist += 10
# print('Дистанция:', dist)

Сумирование последних цифр и остановка в случае нахождениея заранее заданной переменной
# numb = int(input('Введите число: '))
# summ = 0
# while numb != 0:
#   last_num = numb % 10
#   print(last_num)
#   if last_num == 5:
#     print('Обнаружен разрыв:')
#     break
#   summ += last_num
#   numb //= 10
# print('Сумма:', summ)

Сумирование и остановка в случае ввода заранее заданной переменной
# money = int(input('Сколько денег: '))
# win = 0
# while money < 10000:
#   num = int(input('Какое число выпало на кубике: '))
#   if num == 3:
#     print('Вы проиграли все!')
#     money = 0
#     break
#   win += 500
#   money = money + win
#   print('Сумма:', money)
# print('Игра окончена!')
# print('Денег на счету:', money)

Счетчик иттераций цикла
# bags = 5
# bags_count = 0
# total_weight = 0
# while bags > 0:
#   bags_weight = int(input('Сколько весит мешок?: '))
#   bags -= 1
#   total_weight += bags_weight
#   bags_count += 1
#   print('Мешков перенесено: ', bags_count)
#   print('Общий вес мешков: ', total_weight)
# print('Программа завершена')

Как работатет опертор continue
# count = 30
# while count > 0:
#   print(count)
#   count -= 1
#   if count == 23 or count == 13 or count == 3:
#     count -= 1
#     print('Найден разрыв')
#     continue
# print('Отсчет окончен')

print('Задача 4. Календари')

# Напишите программу,
# которая считает количество только чётных чисел в последовательности
# (последовательность заканчивается при вводе нуля)
# и выводит ответ на экран.

# even = 0
# while True:
#   month = input('Введите месяц: ')
#   days = int(input('Введите количество дней в месяце: '))
#   if days == 0:
#     print('Программа завершена')
#     break
#   while days > 0:
#     if days % 2 == 0:
#       even += 1
#     days -= 1
#   print('Четных дней в', month, '=', even)

Посчитать количество знаков в числе
# num = int(input('Введите число: '))
# count = 0
# while num > 0:
#   num //= 10
#   count += 1
# print('Колличество десятичных цифр (знаков) в введенном числе:', count)

print('Задача 5. Счастливый билетик')

# Напишите программу,
# которая получала бы на входе шестизначный номер билета
# и выводила, счастливый это билет или нет.
# К примеру, билеты 666 666 и 252 135 — счастливые,
# а 123 456 — нет.
# Подумайте, нужны ли для решения этой задачи циклы?

# num = int(input('Введите шестизначный номер: '))
# summ_1 = (num // 100000) + (num // 10000 % 10) + (num // 1000 % 10)
# summ_2 = (num // 100 % 10) + (num // 10 % 10) + (num % 10)
# if summ_1 == summ_2:
#   print('Билет счастливый')
# else:
#   print('Билет не счастливый')

# # Можно и с циклом, но я себе мозг сломал) Да и код в разы длиннее вышел))))

# num = int(input('Введите шестизначный номер: '))
# sum_1 = 0
# sum_2 = 0
# while num > 1000:
#   num_1 = num % 10
#   sum_1 += num_1
#   num -= num_1
#   num //= 10
# print(sum_1)
# while num > 0:
#   num_2 = num % 10
#   sum_2 += num_2
#   num -= num_2
#   num //= 10
# print(sum_2)
# if sum_2 == sum_1:
#   print('Поздравляю, у вас счастливый билет!')
# else:
#   print('К сожалению, билет не счастливый')

print('Задача 7. Обычный день на работе')

# Цикл с сумирование и флагом (True/False)
# call_chek = False
# task_count = 0
# clock = 0
# print('Начался 8 - часовой рабочий день')
# while clock < 8:
#   clock += 1
#   print(clock, 'час')
#   task = int(input('Сколько задач решит Максим?: '))
#   call = int(input('Звонит жена. Взять трубку? (1-да, 0-нет): '))
#   if call == 1:
#     call_chek = True
#   task_count += task
# print('Рабочий день закончился. Всего выполнено задач:', task_count)
# if call_chek:
#   print('Нужно зайти в магазин')

print('Задача 10. Игра «Компьютер угадывает число»')

# Поменяйте мальчика и компьютер из прошлой задачи местами.
# Теперь мальчик загадывает число между 1 и 100 (включительно).
# Компьютер может спросить у мальчика:
# «Твое число равно, меньше или больше, чем число N?»,
# где N — число, которое хочет проверить компьютер.
# Мальчик отвечает одним из трёх чисел:
# 1 — равно,
# 2 — больше,
# 3 — меньше.

# Напишите программу,
# которая с помощью цепочки таких вопросов и ответов мальчика угадывает число.

# Дополнительно: сделайте так, чтобы можно было гарантированно угадать число за семь попыток.

# sec_number = int(input('какое загадал число?: '))
# start = 1
# finish = 100
# attempts = 1
# while True:
#   number = (start + finish) // 2
#   print('Твое число', number, '?')
#   chek = int(input('Загаданное число равно, больше или меньше (1 - равно, 2 больше, 3 - меньше) ?: '))
#   if chek == 1:
#     print('Ура, я угадал с', attempts, 'попыток !!!')
#     print('Восстание машин началось! (No Fate)')
#     break
#   elif chek == 2:
#     start = number + 1
#   elif chek == 3:
#     finish = number - 1
#   attempts += 1

Вывод for в отдельной строке, для каждой цифры
# Напишите программу, которая выводит вторую, третью и четвёртую степень для каждого числа в отдельной строке (первая строка - степени для числа 3, вторая строчка - степени для числа 7 и т.д.). Числа: 3,7,5,6,4.
# for number in 3,7,5,6,4:
#  print(number ** 2, number ** 3, number ** 4)

Счастливый билет с циклом for, 2 условия:  делится на 3 и обязательно! 3-х значный
# winer = 0
# for tiket in 345, 19, 87, 1020, 421:
#   if tiket // 300 == 1 and tiket % 3 == 0:
#     winer += 1
#     print(tiket, '- счастливый билет')
#   else:
#     print(tiket, '- билет не счастливый')
# print('Всего счастливых билетов: ', winer)

Квадраты чисел с функцией range
# for numb in range(11):
#   numb **= 2
#   print(numb)

Кукушка спрашивает сколько раз нужно написать "Ку-Ку" (range)
# clock = int(input('Который час? '))
# for clock in range(clock):
#   print('Ку - ку')

Возведение числа (например 2) в степень, которая задана в range
# dig = 2
# for numb in range(21):
#  print(dig ** numb)

Просумировать числа между собой внутри диапазона
# start = int(input('Введите первое число '))
# finish = int(input('Введите последнее число: '))
# summ = 0
# for numb in range(start, finish +1):
#   summ += numb
# print('Сумма чисел от', start, 'до', finish, 'равна', summ)

Подсчет колорий
# awake = int(input('Во сколько проснулся: '))
# unsleep = 0
# sum_colories = 0
# for hour in range(awake, 23):
#   print('Сейчас', hour, 'часов: ')
#   colories = int(input('Сколько съел колорий: '))
#   sum_colories += colories
#   unsleep += 1
#   if sum_colories > 2000:
#     print('Хорошо поел, можно и поспать')
#     break
# print('Съедено колорий:', sum_colories)
# print('Не спал', unsleep, 'часов.')
А вот вариант с использованием step в диапазоне range
# wake_up = int(input('Во сколько проснулся: '))
# calories_summ = 0
# water = 0
# for hours in range(wake_up, 23, 3):
#   water += 1
#   print ('Пошли есть в', hours, 'часов')
#   calories = int(input('Сколько съел: '))
#   calories_summ += calories
# print('Сумма съеденных калорий составила:', calories_summ)
# print('Воды выпито:', water, 'литра')

Определить число простое (делится на 1 и на само себя без остатка) или составное (например при делении на 2 есть остаток)
# number = int(input('Введите число: '))
# simple = True
# for divider in range(2, number):
#   if number % divider == 0:
#     simple = False
#     break
# if simple:
#   print('Число простое')
# else:
#   print('Число составное')

Сколько людей в секторе?
# Мы ответственны за группу секторов с номерами с 30-го по 35-ый
# Напишите программу,
# которая для каждого сектора запрашивает текущее количество людей в нём,
# и если оно больше 10, то фиксирует нарушение.
# В конце выведите количество нарушений
# count = 0
# f_sector = 30
# l_sector = 36
# for sector in range(f_sector, l_sector):
#   print('Сколько людей в секторе', sector, end =''); peoples = int(input(' : '))
#   if peoples > 10:
#     count += 1
#     print('Нарушение! Слишком много людей в секторе!')
#   else:
#     print('Всё спокойно.')
# print('Количество нарушений:', count)

Нахождение факториала '!'(например 5)
# N! = 1 * 2 * 3 * 4 * 5 * … * N
# Пример:
# Введите число: 5
# Факториал числа 5 равен 120
# number = int(input('Введите число: '))
# factorial = 1
# for search in range(1, number + 1):
#   factorial *= search
# print('Факториал числа',number, 'Равен', factorial)

программа запрашивает количество учеников и их оценки (от 3 до 5), и выводит на экран сообщение, кого больше
# rate_3 = 0
# rate_4 = 0
# rate_5 = 0
# stud = int(input('Введите число учеников: '))
# for list in range(1, stud+1):
#   rate = int(input('Какую оценку получил ученик (от 3 до 5): '))
#   if rate == 3:
#     rate_3 += 1
#   elif rate == 4:
#     rate_4 += 1
#   elif rate == 5:
#     rate_5 += 1
# if rate_3 > rate_4 and rate_3 > rate_5:
#   print('Троечников сегодня больше (',rate_3,') человек')
# elif rate_4 > rate_3 and rate_4 > rate_5:
#   print('Хорошистов сегодня больше (',rate_4,') человек')
# elif rate_5 > rate_4 and rate_5 > rate_3:
#   print('Отличников сегодня больше (',rate_5,') человек')
# elif rate_5 == rate_4 and rate_5 > rate_3:
#   print('Отличников и хорошистов сегодня поровну ( по',rate_5,') человек')
# elif rate_4 == rate_3 and rate_4 > rate_5:
#   print('Хорошистов и троечников сегодня поровну ( по',rate_4,') человек')
# elif rate_5 == rate_3 and rate_5 > rate_4:
#   print('Отличников и троечников сегодня поровну ( по',rate_5,') человек')
# elif rate_5 == rate_3 == rate_4:
#   print('Сегодня нет лидеров, все оценки распределились поровну')

Программа которая находит и выводит все двузначные числа, которые равны утроенному произведению своих цифр.
# К таким относятся, например, 15 и 24.

# n = int(input('Введите конечное число диапазона поиска: '))
# for num in range(1, n + 1):
#   prod = ((num // 10) * (num % 10)) * 3
#   if num == prod:
#     print(num)

Поиск недостающей карточки
#Для настольной игры используются карточки с номерами от 1 до N.
# Одна карточка потерялась.
# Найдите ее, зная номера оставшихся карточек.
#
# Вводится число N,
# далее еще N − 1 чисел:
# номера оставшихся карточек (различные числа от 1 до N).
# Программа должна вывести номер потерянной карточки.

# можно доказать формулу:
# sum == n * (n + 1) // 2
n = int(input('Введите общее число карточек: '))
summ = 0
for card in range(1, n + 1):
  summ += card
print(summ)
for card in range(n - 1):
  summ -= int(input('Введите оставшиеся номера: '))
print('Не достает какрточки номер:', summ)

Возведение в куб только четных чисел из диапазона (проверка четности не через if  а через "number *= 2" - такой способ оптимизирует программу и не заставляет ее перебирать весь диапазон на четность)
# n = int(input('Введите конечное значение диапазона: '))
# for number in range (1, n // 2 + 1):
#   number *= 2
#   print('Число', number, '** 3 =', number ** 3)
А вот задача с возведение в степень нечетных решается с помощью третьего значения в range. Оно называется 'step'. то есть это третье значение после запятой: range(1,n,2). То есть шаг говорит функции, какое число брать следующее. И если начало диапазона 1 то через шаг 2, будет нечетное число. И в такой формуле крайнему порога диапазона не нужно добавлять +1
# n = int(input('Введите конечное значение диапазона: '))
# for num in range(1, n, 2):
#   print ('Число', num, 'в степени 2 =', num ** 2)

"Деление клеток" - Мы знаем, что каждые три часа она делится на 2 клетки. Что важно: за счетчик итерации (часов прошло) отвечает totalHours внутри range. Что бы установить 1 проход, который будет равен трем (часам) - нужно разделить (целочисленно) на 3, счетчик внутри range. Если нужно два, то соответсвенно делим на 2
# totalHours = int(input('Сколько всего часов отводится на наблюдение: '))
# cels = 1
# for hours in range(1, totalHours // 3 + 1):
#   cels *= 2
#   print('Часов прошло:', hours * 3 )
#   print('Количество клеток:', cels)
#   print('Часов до конца наблюдения осталось:', totalHours - hours * 3)
#   print()
# print('Наблюдение завершено!')

Отрицательный шаг и применение правил + отсчет не сначала (разобраться, почему не выводится принт перед break)
# total_soldiers = int(input('Сколько солдат в шеренге: '))
# total_ruls = int(input('Сколько всего правил в уставе: '))
# push_up = 0
# for soldier in range(total_soldiers - 4, 0, -4):
#   if total_soldiers < 4:
#     print('Сегодня маловато солдат, обойдемся без отжиманий')
#     break
#   # print('Солдат номер', soldier)
#   # soldier_rule = int(input('Назови количество правил в уставе: '))
#   # if soldier_rule != total_ruls:
#   #   push_up += soldier * 10
#   #   print(' Не правильно! Упал - отжался', push_up, 'раз')
#   #   print()
#   # print(' Общее количество отжиманий:', push_up)

Обратный отсчет с выводом только не четных чисел (без условного оператора - тоесть if использовать нельщя!!!)
# total_sec = int(input('Введите количество секунд: '))
# for sec in range(total_sec // 2, 0, -1):
#   sec = sec * 2 - 1
#   print(sec)
# print('Я иду искать!')

print('Задача 3. Это будет бомба')
# Если ответ “0” (то есть “нет”), то счетчик бомбы уменьшается.
# Если он достиг нуля, то программа выдаёт сообщение “Бомба взорвалась”,
# а если не достиг, то программа вновь переспрашивает,
# не хочет ли игрок обезвредить бомбу, и сообщает, сколько времени осталось до взрыва..
# Если ответ “да”, то программа выводит на экран сообщение о том,
# что бомба обезврежена и сколько секунд оставалось до взрыва.
# total_sec = 10
# disarm = True
# disarm = int(input('Хотите обезвредить бомбу сейчас (Да-1 Нет-0) '))
# for sec in range(total_sec, 0, -1):
#   disarm = int(input('Хотите обезвредить бомбу сейчас или будем дальше нагнетать атмосферу игры? (Да-1 Нет-0) '))
#   print()
#   if disarm:
#     print('Бомба обезврежена за', sec, 'секунд до врзыва')
#     break
#   else:
#     print('До врзыва осталось:', sec, 'секунд')
# if sec <= 1:
#   print('Бомба взовалась!')

print('Задача 6. Письмо')

# квадратный конверт размера 12х12 сантиметров и письмо на квадратном листе бумаги,
# сколько раз нужно сложить письмо пополам,
# чтобы оно поместилось в конверт.

# mail = int(input('Введите размер письма: '))
# count = 1
# step = mail // 4
# for roll_up in range(mail, 13, - step):
#   print(roll_up)
#   count += 1
# print('Что бы письмо поместилось в конверт, егонужно свернуть', count, 'раз')

print('Задача 7. Стипендия')

#Ежемесячная стипендия студента составляет educational_grant руб.,
# а расходы на проживание превышают стипендию и составляют expenses руб. в месяц.
# Рост цен ежемесячно увеличивает расходы на 3%, кроме первого месяца.
# Составьте программу расчета суммы денег,
# которую необходимо получить у родителей один раз в начале обучения,
# чтобы можно было прожить учебный год (10 месяцев), используя только эти деньги и стипендию.
# educational_grant = int(input('Ежемесячная стипендия составляет: '))
# expenses = int(input('Сколько тратим на проживание? '))
# academic = 10
# total_buget = expenses
# for p_money in range(2, academic + 1):
#   expenses = expenses * 1.03
#   total_buget = total_buget + expenses
# print('У родителей нужно попросить сумму в размере', (total_buget - educational_grant * academic), 'рублей')

print('Задача 8. Сумма ряда - гометрическая прогрессия')

# Дано натуральное число N.
# Напишите программу для вычисления следующей суммы ряда (начиная с единицы)
# S = 1 - 1/2 + 1/4 - 1/8 + … (-1)**N * 1/2**N
# number = int(input('Введите натуральное число: '))
# s = 1
# x = 1
# for n in range(1, number + 1):
#   x = ((-1) ** n) / (2 ** n)
#   s = x + s
# print('Член ряда ', x,'сумма ряда ', s)

print('Задача 9. Выражение')
#Дано число x.
# ((x-1)(x-3)(x-7)…(x-63)/
# ((x-2)(x-4)(x-8)…(x-64))

# x = int(input('Введите число x: '))
# denominator = 1
# a = 1
# b = 0
# numerator = 1
# res = 1
# for i in range(1, 7):
#     a = a * 2
#     b = a - 1
#     numerator = numerator * (x - b)
#     denominator = denominator * (x - a )
#     print(a, b, numerator, denominator)
# if denominator == 0:
#     print('Некорректное значение х, на 0 делить нельзя')
# else:
#     res = numerator / denominator
#     print('RES равно ', res)

print('Задача 10. Кинотеатр')

# Напишите программу,
# которая выдаст, как нужно сесть мальчикам и девочкам,
# чтобы рядом с каждым мальчиком сидела хотя бы одна девочка,
# а рядом с каждой девочкой — хотя бы один мальчик.
#
# На вход подаются два числа - кол-во мальчиков X и кол-во девочек Y.
# В ответе выведите какую-нибудь строку,
# в которой будет ровно X символов “B” (обозначающих мальчиков)
# и Y символов “G” (обозначающих девочек), удовлетворяющую условию задачи.
# Пробелы между символами выводить не нужно.
# Если рассадить мальчиков и девочек согласно условию задачи невозможно,
# выведите строку “Нет решения”.

# Пример 1:
#
# Введите кол-во мальчиков: 5
# Введите кол-во девочек: 5
# Ответ: BGBGBGBGBG
#
# Пример 2:
#
# Введите кол-во мальчиков: 5
# Введите кол-во девочек: 3
# Ответ: BGBGBBGB
#
# Пример 3:
#
# Введите кол-во мальчиков: 100
# Введите кол-во девочек: 1
# Ответ: Нет решения

# Boys = int(input('Введите кол-во мальчиков: '))
# Girls = int(input('Введите кол-во девочек: '))
# solution = ''
# if Boys > Girls * 2 or Girls > Boys * 2:
#   print('Нет решения')
# elif Boys >= Girls:
#   k = Boys - Girls
#   for BGB in range(k):
#     solution += 'BGB'
#   for BG in range(Girls - k):
#     solution += 'BG'
# else:
#   k = Girls - Boys
#   for GBG in range(k):
#     solution += 'GBG'
#   for GB in range(Boys - k):
#     solution += 'GB'
# print(solution)

=========================Работа со строками===========================================
#====================================================================================
Опрос учителем:
# mistake = 0
# for stud in range(5):
#   answer = input('Кто написал Онегина? ')
#   if answer == 'Пушкин' or answer == 'пушкин':
#     print('Правильно!')
#     break
#   print('Не правильно! Садись, два!')
#   mistake +=1
# print('Кол-во двоек: ', mistake)
Если количество циклов не известны, можно так:
answer = ''
# while answer != 'Да, конечно, сделал':
#   quest = input('Выполнил ли ты задание, которые я выдавал вчера? ')
#   answer = quest
# print('Молодец мой кожаный друг)')

Дразнилка (купи слона)
# username = input('Как тебя зовут? ')
# print(username, 'купи слона!')
# while True:
#   answer = input('')
#   print('Все говорят '+ answer + ', а ты купи слона!')

Вывод символов фразы в столбик (можно по нескольку штук)
# phraze = input('Введите фразу:  ')
# for sym in phraze:
#   print(sym * 5)
#   print('=' * 10)

Подсчет количества букв в тексте
# text = input('Введите текст:  ')
# lit_1 = input('Введите первую букву поиска: ')
# lit_2 = input('Введите вторую букву поиска: ')
# lit_1_count = 0
# lit_2_count = 0

# for lit in text:
#   if lit == lit_1:
#     lit_1_count += 1
#   if lit == lit_2:
#     lit_2_count += 1

# print('Кол-во больших букв ', lit_1, '=', lit_1_count)
# print('Кол-во маленьких букв ', lit_2, '=', lit_2_count)

Использование оператора end (он может добавлять пробел и продолжать вывов инфы в эту же строку, и не переходить на новую)
# phraze = input('Введите фразу: ')
# for sym in phraze:
#   print(sym, end = ' ')

Нарисовать (доску) из симоволов с использование циклов и оператора (end)
# for y in range(6):
#   for x in range(10):
#     if y == 0 or y == 5:
#       print('-', end='')
#     elif  x == 0 or x == 9:
#       print('|', end='')
#     else:
#       print(0, end='')

#   print() #вот этот принт позволяет напечатать прописанные в цикле значения каждое в новой строке, то же самое было бы, если бы в скобках принта было бы написано end = '\n'
Или с конкотинацией и циклом + end = '\n'
# print('-' * 10, end = '\n')
# for i in range(4):
#   print('|' + '0' * 8 + '|')
# print('-' * 10, end = '\n')


Задача про генерацию IP. Внутри прогрессия. Пользователь вводит число и шаг. Прогрмма выдает готовый IP в котором первые три цифры - прогрессия, а последняя - сумма трех предыдущих, ну и оператор end на месте (обратить внимание на его расположение)
# num = int(input('Введите первое число: '))
# step = int(input('Введите шаг: '))
# summ = 0

# print(end = '\n' + 'IP config: ')
# for i in range(3):
#   print(num, end = '.')
#   summ += num
#   num = num + step

# print(summ)

Вывод каждого 10 го числа с разделением между цифрами (-=-)
# gol = int(input('Введите кол-во голов: '))
# count = 0

# print(end = '-=-')
# for point in range(gol // 10):
#   count += 10
#   print(count, end = '-=-')

Как отфильтровать текст от цифр
# text = input('Введите тескст: ')
# summ = 0
# print('\nОтфильтрованный текст: ', end = '')
# for symbol in text:
#   if symbol == '1' or symbol == '9':
#     summ += int(symbol)
#   else:
#     print(symbol , end = '')
# print('\nСумма: ', summ)

Две одинаковые буквы подряд
# string = input('Введите тескст: ')
# prevSym = ''
# equalSym = False
# for letter in string:
#   if prevSym == letter:
#     equalSym = True
#     break
#   else:
#     prevSym = letter

# if equalSym:
#   print('Есть две одинаковые буквы идущие подряд.')
# else:
#   print('Нет одинаковых букв идущих подряд.')

Вывод номера дня недлии в ответ на название дня недели
# w_day = input('Введите день недели: ')
# chek = 1

# for day in ('понедельник', 'вторник', 'среда', 'четверг', 'пятница', 'суббота', 'воскресенье'):
#   if day == w_day:
#     print('Номер дня недели: ', int(chek))
#     break
#   else:
#     chek += 1

Поиск символа и вывод номера его позиции в тексте
# message = input('Введите сообщение (не забудьте добавить "*"): ')
# count = 1
# chek_sym = False

# for sym in message:
#   if sym == '*':
#     chek_sym = True
#     break
#   else:
#     count += 1

# if  chek_sym:
#   print("\nСимвол '*' стоит на позиции", count)
# else:
#   print("Лишних символов в сообщении не обнаружено")

Оператор марсохода
# dir_x = 8
# dir_y = 10

# while True:
#   print('[Программа]: Марсоход находится на позиции', dir_x,',',dir_y, end = '')
#   n_position = input(' введите команду: \n[Оператор]: ')
#   if n_position == 'w' and 0 < dir_x < 15:
#     dir_x += 1
#   elif n_position == 's' and 0 < dir_x < 15:
#     dir_x -= 1
#   elif n_position == 'd'  and 0 < dir_y < 20:
#     dir_y += 1
#   elif n_position == 'a' and 0 < dir_y < 20:
#     dir_y -= 1

Самая длинная последовательность (ищем букву "s") и сравниваем количество ее повторений подряд в одной строке
# string = input('Введите строку: ')
# summ = 0
# max_summ = 0

# for sym in string:
#   if sym == 's' or sym == 'S':
#     summ += 1
#     if summ > max_summ:
#       max_summ = summ
#   else:
#     summ = 0
# print('Самая длинная последовательность:', max_summ)

Колонтитул
print('Задача 8. Колонтитул')

# Нам нужно написать программу для печати важных объявлений.
# Сверху объявления должен располагаться вот такой колонтитул:
#  ~~~~~~~~~~!!!!!!~~~~~~~~~~
# Восклицательные знаки всегда располагаются по центру строки,
# row = 1
# length = int(input('Введите длину колонтитула в символах: '))
# exclamation = int(input('желаемое количество восклицательных знаков: '))
# half = (length - exclamation) // 2

# for symbol in range(row):
#   rows = '~' * half + '!' * exclamation + '~' * half
#   print()
#   print(rows)

print('Задача 9. Коровы')

# Для коров есть 10 стойл.
# В каждом стойле разные условия для животных, поэтому и молока они дают по-разному.
# В первом стойле производят 2 литра в день,
# во втором 4,
# в третьем - 6, потом 8, 10, 12, 14, 16, 18, 20.
# Но коровы стоят не во всех стойлах.
# Свободные и занятые обозначаются строкой из букв a и b,
# где a - свободное стойло, b - занятое.
# #
# # Пользователь вводит строку из 10 символов a и b.
# # Необходимо определить, сколько в итоге будет произведено молока за день.

# stables = input('Введите строку из 10 символов a/b: ')
# count = 0
# summ = 0

# for stable in stables:
#   count += 2
#   # print(count)
#   if stable == 'b' or stable == 'B':
#     summ += count

# print('\nЗа день будет произведено', summ, 'литров молока')

 Пример:
# Введите зашифрованное сообщение: shacnidw
# Расшифрованное сообщение: sandwich
#          1   3   5   7   8   6   4   2
# Слово: | s | a | n | d | w | i | c | h |
#
# Шифр:  | s | h | a | c | n | i | d | w |

Метод бутерброда
# text = input('Введите зашифрованное слово: ')
# summ_1 = ' '
# summ_2 = ' '
# count = 0

# for letter in text:
#   count += 1
#   if (count % 2 == 1):
#     summ_1 += letter
#     # print(summ_1)
#   else:
#     summ_2 = letter + summ_2
#     # print(summ_2)
# print('Расшифрованое слово', summ_1 + summ_2)

Распечатать таблицу умножения))))
# for a in range(1, 10):
#   for b in range (1, 10):
#     print(a, '*', b, '=', a * b)
#   print()
или только результаты умножения в таблице с табуляцией ( end = '\t')
# for a in range(1, 10):
#   for b in range(1, 10):
#     print(a * b, end = '\t')
#   print()
или таблица сумм с отрицательными столбцами
# for row in range(0, 10, 1):
#   for col in range (0, -10, -1):
#     print(row + col, end = '\t')
#   print()
или таблица сумм с вводом значения для таблицы от пользователя
# n = int(input('Введите число для таблицы: '))
# print()

# for row in range(n):
#   for col in range (n):
#     print(row + col, end = '\t')
#   print()

Напишите программу, которая выводит квадратную матрицу размера N на N. В каждой нечётной строке матрицы идут числа от 1 до N, а в каждой чётной — просто числа, равные номеру этой строки.
# n = int(input('Введите число для таблицы: '))

# for row in range(1, n + 1):
#   for col in range (1, n + 1):
#     if row % 2 == 0:
#       print(row, end = ' ')
#     else:
#       print(col, end = ' ')
#   print()

нарисовать перекрестье
# for row in range(20):
#   for col in range (50):
#     if row == 9:
#       print('-', end = '')
#     elif col == 24:
#       print('|', end = '')
#     else:
#       print(' ', end = '')
#   print()

нарисовать дорогу (обрать внимание на обратынй слеш. Если его нужно вывести на эекран, их должно быть 2! Так как один используется для литералов типа n или t )
# for row in range(20):
#   for col in range (50):
#     if row == 9:
#       print('-', end = '')
#     elif col == row + 29:
#       print('\\', end = '')
#     elif col == - row + 19:
#       print('/', end = '')
#     elif col == 24:
#       print('|', end = '')
#     else:
#       print(' ', end = '')
#   print()

Напишите программу, которая получает на вход размер квадратной матрицы и выводит на экран по такому принципу диагональ из единиц с левого нижнего угла до верхнего правого, ниже диагонали — двойки, выше — нули.
# n = int(input('Введите размер матрицы: '))

# for row in range(0, n + 1):
#   for col in range (0, n + 1):
#     if col ==  - row + n:
#       print(1, end = ' ')
#     elif col < - row + n:
#       print(0, end = ' ')
#     else:
#       print(2, end = ' ')
#   print()

Напишите программу, которая получает на вход размер квадратной матрицы и выводит на экран по такому принципу диагональ из единиц с левого верхнего угла до нижнего правого, ниже диагонали — двойки, выше — нули.
# n = int(input('Введите размер матрицы: '))

# for row in range(0, n + 1):
#   for col in range (0, n + 1):
#     if row == col:
#       print(1, end = ' ')
#     elif col > row:
#       print(0, end = ' ')
#     else:
#       print(2, end = ' ')
#   print()

Каждый час уменьшает очередь на 1 человека
# people = int(input('Введите кол-во людей: '))
# for hour in range(people):
#   print('Идет час:', hour)
#   for num in range(hour, people):
#     print('Номер в очередеи:', num)
#   print()
# print('Очередь обслужена!')

Подсчет количества цифр больше 5
# seq = int(input('Введите последовательность чисел: '))
# numCount = 0

# while seq > 0:
#   if (seq % 10) > 5:
#     numCount += 1
#   seq = seq// 10

# print('Общее количество цифр в последовательноти, больше пяти равно = ', numCount)

print('Задача 2. Лестница')

# Пользователь вводит число N.
# Напишите программу, которая выводит такую “лесенку” из чисел:

# Введите число: 5
# 1
# 2 2
# 3 3 3
# 4 4 4 4
# 5 5 5 5 5

# N = int(input('Введите число: '))

# for row in range(N):
#   for col in range(N):
#     if row == col:
#       print(col + 1, end = ' ')
#     elif row > col:
#       print (row + 1, end = ' ')
#   print()

print('Задача 3. Рамка')

#  _ _ _ _ _ _ _ _ _
# |                 |
# |                 |
# |                 |
# |                 |
# |                 |
# |                 |
# |_ _ _ _ _ _ _ _ _|

# higth = int(input('Введите высоту рамки: '))
# wigth = int(input('Введите ширину рамки: '))

# for row in range(1, higth + 1):
#   for col in range(1, wigth + 1):
#     if col == 1 or col == wigth:
#       print('|', end = '')
#     elif row == 1 or row == higth:
#       print('-', end = '')
#     else:
#       print(' ', end = '')
#   print()
Что бы посередине бфло по 2 символа, в одно из условий col + 1 прописываем
# ^        ^
#  ^      ^
#   ^    ^
#    ^  ^
#     ^^
#     ^^
#    ^  ^
#   ^    ^
#  ^      ^
# ^        ^

# n = int(input('Введите размер матрицы: '))

# for row in range(n):
#   for col in range (n):
#     if col == row:
#       print('^', end = '')
#     elif col + 1 == - row + n:
#       print('^', end = '')
#     else:
#       print(' ', end = '')
#   print()

print('Задача 5. Простые числа')

Программа проверки на простые числа
#которая считает количество простых чисел в заданной последовательности
#ищем методом перебора делителей.

# seq = int(input('Введите диапазон проверки: '))
# numCount = 0

# for num in range(2, seq + 1):
#   for divider in range(2, num):
#     if num % divider == 0:
#       break
#   else:
#     numCount += 1

# print('\nПростых чисел в последовательности:', numCount)

Поиск наименьшего делителя, отличного от 1
# def least():
#     for divider in range(2, num + 1):
#         if num % divider == 0:
#             break
#     return divider
#
# num = int(input('Введите число: '))
#
# print('Наименьший делитель, отличный от единицы:', least())

print('Задача 6. Сумма факториалов')

# number = int(input('Введите число диапазона: '))
# summ = 0

# for count in range(1, number + 1):
#   factorial = 1
#   for num in range (1, count + 1):
#     factorial *= num
#   #   print('факториал', num, 'равен = ', factorial )
#   # print()
#   summ += factorial

# print('\nСумма факториалов диапазона',number, 'равна', summ)

print('Задача 7. Наибольшая сумма цифр')
# # найдите наибольшее по сумме цифр из введенных. Выведите на экран это число и сумму его цифр.

# seqNum = int(input('Сколько чисел будем проверять? '))
# max_m = 0
# max_sum =0
# summ = 0
# for num in range(1, seqNum + 1):
#   print('Введите', num, '- ое число', end = ' ')
#   number = int(input())
#   this_num = number
#   while number > 0:
#     summ += number %10
#     number //= 10
#     if summ > max_sum:
#       max_sum = summ
#       max_num = this_num
#   summ = 0
# print('\nМаксимальное число',max_num,'имеет максимальную сумму цифр:', max_sum)

Пирамидка

   #
  ###
 #####
#######

# higth = int(input('Введите высоту пирамиды: '))
# count = 1

# for row in range(higth):
#   print((' ' * (higth - row)) + '#' * count + (' ' * (higth - row)))
#   count += 2
#   row += 1

print('Задача 9. Пирамидка 2')
ЛХ №1 Диапазон вложенного цикла взят как диапазон строк (row), так как нам нужно печатать количество цифр в каждой строке, равное номеру этой строки
ЛХ №2 Если несколько переменных в сумме дают один и тот же результат на протяжении цикла - нужен отрицательный шаг
ЛХ №3 Математическая фишка: Есил line + spececounr = rows, то specount = rows - line (просто переносим line вправо)
#             1
#          3     5
#       7     9     11
#    13    15    17    19
# 21    23    25    27    29

# lev = int(input('Введите количество уровней пирамиды: '))
# n_num = 1

# for row in range(lev):
#   gap = lev - row - 1
#   print('   ' * gap, end = '')
#   for num in range(row + 1):
#     print(n_num, end = '    ')
#     n_num += 2
#   print()

Задача - яма. Лучше сначала делать левую часть, потом правую и в конце добавлять точки
# 5........5
# 54......45
# 543....345
# 5432..2345
# 5432112345

# n = int(input('Введите число для ямы: '))
# print()

# for row in range(n):
#   for l_num in range(n, n - row - 1, - 1):
#     print(l_num, end = '')
#   dot_count = (n - row - 1) * 2
#   print('.' * dot_count, end = '')
#   for r_num in range(n - row, n + 1):
#     print(r_num, end = '')
#   print()
====================================================================================

Использование float и round
Коэффициент массы тела
# height = float(input('Введите рост в метрах: '))
# while height >= 2.5:
#   print('\nРост не может привышать значение в 2.5.')
#   print('Введите корректное значение ростта в метрах: ', end ='')
#   height = float(input())
# weight = float(input('Введите вес: '))
# k = round(weight / height ** 2, 2)

# print('\nКоэффициент веса =', k)
# if k < 18.5:
#   print('Недобор веса!')
# elif k >= 19 and k <= 25:
#   print('Вес в норме!')
# elif k > 25 and k <= 30:
#   print('Избыток веса!')
# else:
#   print('Ожирение!')

Приведение типа (приводим тип float к типу int).
ЛХ №1 Если мы в коде указываем тип (int или float) - то это явное приведение типа. Если питон сам меняет тип данных в расчетах - то это не явное приведение
# while True:
#   force = float(input('Введите силу удара (от 0 до 1): '))
#   force *= 10
#   print('Сила удара = ', int(force))

В далеком (а может и не очень) будущем на некоторой планете можно купить космический корабль за пол-кредита (CR). Один CR это 2200 чатлов. Причем чатлы неделимы и являются всегда целым числом. Напишите простую программу-конвертор валют. В программу вводится количество чатлов, а она сообщает сколько это CR и сколько кораблей можно купить на эту сумму.

# Пример 1:

# Сколько чатлов? 3150
# Это 1.4318181818181819 CR
# Можно купить кораблей: 2

# Пример 2:
# Сколько чатлов? 4400
# Это 2.0 CR
# Можно купить кораблей: 4
# chat = int(input('Сколько чатлов: '))
# ex_rate = 2200
# pay = float(chat / ex_rate)
# buy = int(pay // 0.5)

# print('Это:', pay, 'CR')
# print('Можно купить кораблей:', buy)

Шахматы (с поправкой позиции)
# while True:
#   x = float(input('Введите значение по горизонтали: '))
#   y = float(input('Введите значение по вертикали: '))

#   if 0 < x > 1:
#     print('Введенные координаты', int(x), 'выходят за пределы доски, повторите ввод:', end = '')
#     x = float(input())
#   elif 0 < y > 1:
#     print('n\Введенные координаты', int(y), 'выходят за пределы доски, повторите ввод:', end = '')
#     y = float(input())

#   x_squer = int(x * 10)
#   y_squer = int (y * 10)

#   print('\nФигура находится в клетке:', x_squer, y_squer)
#   x_squer = x_squer+ 0.5
#   y_squer = y_squer + 0.5

# #ищем поправку
#   x = round((x_squer / 10 - x), 3)
#   y = round((y_squer / 10 - y), 3)
#   print(x, y)
#   print()

Формула герона (площадь треугольника)
#  import math
# a = float(input('Введите длину стороны а: '))
# b = float(input('Введите длину стороны b: '))
# c = float(input('Введите длину стороны c: '))
# p = (a + b + c) / 2 # полупериметр треугольника

# s = math.sqrt(p * (p - a) * (p - b) * (p - c))

# print('\nПлощадь треугольника =', round(s, 3))

Радар!
# import math
# distance = float(input('Введите расстояние до танка: '))
# angle = float(input('Введите угол поворота: '))

#   # sin угла = Oy/Oa (отношение противолежащего катета к гипотенузе - ось у деленная на ось гепотинузы)
#   # cos угла = Ox/Oa (отношение прилежащего катета к гипотенузе - ось x деленная на ось гепотинузы)
#   # Значит что бы посчитать координаты оси X и Y на тригонометрической окружности, делаем математический перенос:
#   # Oy = sin(угла) * Oa
#   # Ox = cos(угла) * Ox
#   # Функции ожидают значенпия угла в радианах (сколькол это в градусах, надо гуглить), поэтому сразу сконвертируем градусы в радианы

# angle /= 57.2958
# x = math.cos(angle) * distance
# y = math.sin(angle) * distance

# print('Координаты танка:', x, 'и', y)

Мегаконвертер (плюс проверка числа на натуральность)
# import math
# num = float(input('Введите число: '))

# print('\nОкругление вниз:', math.floor(num))
# print('Округление вверх:', math.ceil(num))
# print('Квадратный корень:', math.sqrt(num))
# print('Экспонента в степени', num, ':', math.exp(num))
# print('Натуральный логорифм числа:', math.log(num))
# print('логарифм числа по основанию 2:', math.log2(num))
# print('логарифм числа по основанию 10:', math.log10(num))
# print('sinus числа:', math.sin(num))
# print('cosinus числа:', math.cos(num))
# if num % 1 == 0 and num > 0:
#   print('Факториал числа:', math.factorial(num))
# else:
#   print('Факториал числа вычислить нельзя, так как число', num, 'не является натуральным')

print('Задача 2. Грубая математика')
# Вводится последовательность из N вещественных чисел.
# При этом положительные числа округляются вверх, отрицательные округляются вниз.
# выводит натуральный логарифм от числа,
# если оно положительное, и экспоненту в степени числа, если оно отрицательное.

# import math
# seq = int(input('\nВведите кол-во чисел: '))

# for i in range(1, seq + 1):
#   print('\nВведите', i, '- ое число: ', end = '')
#   num = float(input())
#   if num > 0:
#     print('x =', math.ceil(num), end = '   ')
#     print('log (x) =', math.log(math.ceil(num)))
#   else:
#     print('x =', math.floor(num), end = '   ')
#     print('exp(x) =', math.exp(math.floor(num)))

Индикатор загрузки,
# принимающую на вход размер файла обновления в мегабайтах и скорость интернет соединения в мегабайтах в секунду.
# Для каждой секунды программа рассчитывает и выводит на экран сколько процентов от всего объема уже скачано, до тех пор пока не будет скачан весь объем.

# import math
# while True:
#   size = float(input('Укажите размер файла: '))
#   speed = float(input('Какова скорость вашего соединения? '))
#   print()
#   if size < 1 or speed < 1:
#     print('Значение скорости и размера не должны быть меньше 1, повторите ввод', end = '\n')
#   else:
#     break

# second = 1
# size = int(size)
# speed = int(speed)

# for mb in range(speed, size, speed):
#   print('Прошло', second, 'сек. Скачано', mb, 'из', size, 'Мб','(', math.ceil(mb/(size/100)), '%)')
#   second += 1
# else:
#     print('Прошло', second, 'сек. Скачано', size, 'из', size, 'Мб (100 %)')
#     print('\nЗагрузка завершена! Скачивание заняло:', second, 'сек.')

print('Задача 5. Вот это объёмы!')
# Объём Земли ему известен заранее  - это 10.8321 * 10 ** 11 км3
# V = 4/3 πR ** 3
# # где V - это объём, π - число пи, а R - радиус планеты.
# #
# # Напишите программу,
# # которая получает на вход радиус случайной планеты
# # и выводит на экран во сколько раз планета Земля меньше или больше по объёму.
# # Ответ округлите до трёх знаков после запятой

# # Пример:
# # Введите радиус случайной планеты: 3389.5
# # Объём планеты Земля больше в 6.641 раз

# # Пример 2:
# # Введите радиус случайной планеты: 7000
# # Объём планеты Земля меньше в (1/0.754) = 1.326 раз
# import math

# R = float(input('Введите радиус планеты: '))
# V = 10.8321 * (10 ** 11)
# V1 = round(4 * math.pi/3 * (R**3), 3)
# if V1 < V:
#   print('Объём планеты Земля больше в', round(V/V1, 3), 'раз')
# else:
#   print('Объём планеты Земля меньше в', round(V1/V, 3), 'раз')
Таблица температур
# таблицу соответствия градусов Цельсия градусам Фаренгейта
# от нижней до верхней границы с указанным шагом.
# down = int(input('Нижняя граница температуры: '))
# up = int(input('Верхняя граница температуры: '))
# step = int(input('Шаг: '))
# zero_c = 32
# grad_c = 1.8
# grad_f = 0

# print('\nC          F')
# print()
# for table in range(down, up, step):
#   print(table, '       ', int(zero_c + (table * grad_c)))
# else:
#   print(up, '       ', int(zero_c + (up * grad_c)))

print('Задача 8. Часы')

# С начала суток часовая стрелка повернулась на угол в α градусов.
# Определите на какой угол повернулась минутная стрелка с начала последнего часа.
# Входные и выходные данные — действительные числа.
#За час минутная стрелка совершает полный оборот (1 круг == 360°), а часовая стрелка передвигается на один час (1/12 круга == 30°). Поэтому полный угол поворота минутной стрелки в 12 раз больше, чем угол поворота часовой стрелки.
# Угол поворота часовой стрелки с начала последнего часа это остаток от деления на 30

# degree = float(input('Введите угол поворота часовой стрелки: '))
# answer = (degree % 30) * 12
# print('Минутная стрелка с начала последнего часа, повернулась на угол:', answer)

print('Задача 9. Уравнение')

# Даны действительные коэффициенты a, b, c,
# при этом a≠0.
# Решите квадратное уравнение ax^2+bx+c=0 и выведите все его корни.
#
# Если уравнение имеет два корня,выведите два корня в порядке возрастания,если один корень — выведите одно число,если нет корней — не выводите ничего

# import math

# print("Введите коэффициенты для уравнения")
# print("ax^2 + bx + c = 0:")

# a = float(input("a = "))
# b = float(input("b = "))
# c = float(input("c = "))

# discr = b ** 2 - 4 * a * c
# print('\nДискриминант равен:',discr)

# if discr > 0:
#     x1 = (-b + math.sqrt(discr)) / (2 * a)
#     x2 = (-b - math.sqrt(discr)) / (2 * a)
#     print('\nx1 =', round(x1, 2), 'x2 =', round(x2, 2))
# elif discr == 0:
#     x = -b / (2 * a)
#     print('\nx =', round(x, 2))
# else:
#     print("Корней нет")

Поиск максимального числа без циклов, условынх операторов и функций (только математика!).
Используем старый прием "поменяй местами" и бинарное деление
# Введите первое число: 10
# # Введите второе число: 5
# #
# # Наибольшее число: 10

# a = int(input('\nВведите число а: '))
# b = int(input('Введите число b: '))

# maxnum = (a + b + abs(a-b)) / 2

# print('\nНаибольшее число:', int(maxnum))

====================================================================================
==========================Использование функций=======================================
Заказ еды:
# def how_much():
#   a = int(input())
#   b = int(input())
#   print("Всего", a+b, "шт.")

# print("Сколько мешков рыбы и мяса?")
# how_much()
# print("\nСколько буханок белого и чёрного хлеба?")
# how_much()
# print("\nСколько вёдер воды и молока?")
# how_much()

Функция с аргументом (в скобках указываем переменные, в теле привязываем их к принту, а при вызове функции просто вписываем нужное имена, то есть меняем аргумент.
Важно соблюдать порядок переменных, он такой же, как и указывали в скобках функции )
# def post(f_name, l_name, country, city, street, house, appart):
#   print('Имя:', f_name)
#   print('Фамилия:', l_name)
#   print('Страна проживания:', country)
#   print('Город:', city)
#   print('Улица:', street)
#   print('Дом:', house)
#   print('Квартира:', appart)
#   print()

# post('Сергей', 'Ярощук', 'Россия', 'Ростов-на-Дону', 'Чаленко', 17, 124)
# post('Алина', 'Ярощук', 'Россия', 'Шадринск', 'Ленина', 12, 104)
# post('Нина', 'Ярощук', 'Россия', 'Морозовск', 'Халтурина', 137, 'нет')

Уравнение (X от -10 до 10):
    { e ** x, -5 <= x <= 5
y = { 2|x| - 1, x < -5
    { 2x, x > 5
В котором e ** X - это экспонента (модуль math. exp), |x| - означает модуль числа (всегда положительное, даже если само число со знаком минуч), за это отвечает модуль 'abs'
Записать это можно вот так:
# import math

# def func(x):
#  if -5 <= x <= 5:
#    print('x =', x, 'y =', math.exp(x))
#  elif x < -5:
#    print('x =', x, 'y =', 2 * abs(x) - 1)
#  else:
#    print('x =', x, 'y =', 2 * x)

# for x in range (- 10, 11):
#   func(x)

Вот это объемы 2
Важно! Если есть дробь, например 4/3 и ее надо умножить на число ПИ, то в Phyton записывается это так: 4 * math.pi/3 - то есть числитель умножаем на число ПИ, деленное на знаменатель
# import math
# R = float(input('Введите радиус планеты: '))

# def sphereArea():
#   S = round(4 * math.pi * (R**2), 3)
#   print('\nПлощадь планеты равна:', S)

# def sphereVolume():
#   V = round(4 * math.pi/3 * (R**3), 3)
#   print('\nОбъем планеты равен:', V)

# sphereArea()
# sphereVolume()

Навигатор
# import math

# def myDistance(x, y):
#   distance = math.sqrt(x ** 2 + y ** 2)
#   print(distance)

# def beetwinDistance(x_1, y_1, x_2, y_2):
#   distance = math.sqrt((x_2 - x_1) ** 2 + (y_2 - y_1) ** 2)
#   print(distance)

# choise = int(input('1 - Расстояние до точки, 2 - расстояние от точки до точки: '))

# if choise == 1:
#   x = float(input('Введите координату X: '))
#   y = float(input('Введите координату Y: '))
#   myDistance(x, y)
# elif choise == 2:
#   x_1 = float(input('Введите координату X первой точки: '))
#   y_1 = float(input('Введите координату Y первой точки: '))
#   x_2 = float(input('Введите координату X второй точки: '))
#   y_2 = float(input('Введите координату Y второй точки: '))
#   beetwinDistance(x_1, y_1, x_2, y_2)
# else:
#   print('Ошибка ввода!')

print('Задача 3. Апгрейд калькулятора')
Программа на выбор находит наибольшую цифру в числе или наименьшую или сумму цифр в числе

# def summ(num):
#   chek = num
#   summa = 0
#   while chek:
#     summa += chek % 10
#     chek //= 10
#   print('\nСумма цифр числа', num, '=', summa)

# def max_num(num):
#   chek = num
#   max = 0
#   while chek:
#     if(chek % 10 > max):
#       max = chek % 10
#     chek //= 10
#   print('\nСамая большая цифра в числе', num, '=', max)

# def min_num(num):
#   chek = num
#   min = num % 10
#   while chek:
#     if (chek % 10 <= min):
#       min = chek % 10
#     chek //= 10
#   print('\nНаименьшая цифра в числе', num, '=', min)

# def mainMenu():
#   print('\nВыберете действие:')
#   print('1 - вывести сумму цифр, 2 -  вывести максимальную цифру, 3 - вывести минимальную   цифру: ', end = '')
#   act = int(input())
#   if act == 1:
#     summ(num)
#   elif act == 2:
#     max_num(num)
#   elif act == 3:
#     min_num(num)
#   else:
#     print('Ошибка ввода! В выборе действия нужно ввести 1, 2 или 3')
#     mainMenu ()


# while True:
#   num = int(input('\nВведите число: '))
#   mainMenu()
#   if num == 0:
#     print('Програма завершена!')
#     break


Программа для вывода числа наоборот (с нолями и без), с использованием функции

# def func_choiсe():
#   print('\nКак будем выводить число?')
#   out = int(input('1 - Выводим с нолями, 2 - выводим без нолей: '))
#   if out == 1:
#     revers(seq)
#   elif out == 2:
#     revers_2(seq)
#   else:
#     print('Ошибка ввода!')
#     func_choiсe()

# def revers_2(seq): #Для вывода числа без нолей
#   n_seq = 0
#   while seq:
#     digit = seq % 10
#     seq = seq // 10
#     n_seq = n_seq * 10
#     n_seq = n_seq + digit

#   print('\nЧисло наоборот:', n_seq)


# def revers(seq):
#   n_seq = ''
#   while seq:
#     n_seq += str(seq % 10)
#     seq //= 10

#   print('\nЧисло наоборот:', n_seq)


# while True:
#   seq = int(input('\nВведите последовательность чисел (должна заканчиватся нулём): '))
#   if seq == 0:
#     print('Программа завершена!')
#     break
#   elif seq > 0:
#     func_choiсe()
#   else:
#     print('Ошибка ввода!')

Подсчет букв и цифр в тексте

# def l_count():
#   l_count = 0
#   for i in text:
#     if i == lit:
#       l_count += 1
#   print('Количество букв', lit,':', l_count)

# def d_count():
#   d_count = 0
#   for i in text:
#     if i == dig:
#       d_count += 1
#   print('\nКоличество цифр', dig,':', d_count)


# text = input('Введите текст: ')
# dig = input('Какую цифру ищем? ')
# lit = input('Какую букву ищем? ')

# d_count()
# l_count()

Металоискатель
Ищем в обозначенной области по заданным координатам Х и У точку. На заметку: Извлечь квадратный корень из числа = умножить число на 0.5

# import math

# def search(x, y):
#   distance = math.sqrt(x ** 2 + y ** 2)
#   print(abs(distance))
#   zone = 1
#   if zone > abs(distance):
#     print('\nМонетка где-то рядом')
#   else:
#     print('\nМонетки в области нет')


# x = float(input('Введите координаты Х: '))
# y = float(input('Введите координаты Y: '))

# search(x, y)

print('Задача 8. НОД')
Напишите функцию, вычисляющую наибольший общий делитель двух чисел

# def GCD( a, b):
#   gcd = 0
#   if a > b:
#       temp = b
#   else:
#       temp = a
#   for i in range(1, temp + 1):
#     if(( a % i == 0) and(b % i == 0 )):
#       gcd  = i
#   print('\nНаибольший делитель двух чисел =', gcd )

# a = int(input('Введите первое число: '))
# b =int(input('Введите второе число: '))
# GCD(a, b)
Так же можно через встроенную функцию в math
# import math
# a = int(input('Введите первое число: '))
# b =int(input('Введите второе число: '))
# num = math.gcd(a, b)
# print('\nНаибольший делитель двух чисел =', num )

print('Задача 9. Недоделка')

# Вы пришли на работу в контору по разработке игр,
# целевая аудитория которых - дети и их родители.
#
# У прошлого программиста было задание
# сделать две игры в одном приложении, чтобы пользователь мог выбирать одну из них.
#
# Однако программист, на место которого вы пришл
# и, перед увольнением не успел сделать эту задачу и оставил только небольшой шаблон проекта.
#
# Используя этот шаблон,
# реализуйте игры «Камень, ножницы, бумага» и «Угадай число».
#
# Правила игры «Камень, ножницы, бумага»:
# программа запрашивает у пользователя строку
# и выводит победил он или проиграл.
#
# Камень бьёт ножницы, ножницы режут бумагу, бумага кроет камень.
#
# Правила игры “Угадай число”:
# программа запрашивает у пользователя число до тех пор, пока он его не отгадает.

Две игры на выбор (Угадай число и камень ножницы) - Важно обратить внимание на (from random import randrange ()) и то как с ним работаем
# def rock_paper_scissors():

#   from random import randrange

#   print('\nПарвила игры: Камень бьёт ножницы, ножницы режут бумагу, бумага кроет камень', end = '\n')
#   print('\n1 - КАМЕНЬ', '\n2 - НОЖНИЦЫ', '\n3 - БУМАГА')
#   while True:
#     choice = int(input('\nВаш выбор? '))
#     if choice == 0:
#       print('\nИгра завершена!')
#       break
#     elif choice == 1:
#       print('\nВаш выбор - КАМЕНЬ')
#     elif choice == 2:
#       print('\nВаш выбор - НОЖНИЦЫ')
#     elif choice == 3:
#       print('\nВаш выбор - БУМАГА')
#     else:
#       print('Ошибка ввода! Повторите выбор, введите 1, 2 или 3')
#       choice = int(input('\nВаш выбор? '))

#     pc_choice = randrange(3) + 1
#     if pc_choice == 1:
#       print('Выбор компьютера - КАМЕНЬ')
#     elif pc_choice == 2:
#       print('Выбор компьютера - НОЖНИЦЫ')
#     elif pc_choice == 3:
#       print('Выбор компьютера - БУМАГА')

#     if pc_choice == choice :
#       print('\nНичья...')
#     elif pc_choice == 1 and choice == 2 or pc_choice == 2 and choice == 3 or pc_choice == 3 and choice == 1 :
#       print('\nПобедил компьютер!', 'Восстание машин началось (NO FATE)')
#     else:
#       print('\nУра!!! Вы попбедили! Восстание машин откладывается')

# def guess_the_number():
#   sec_num = 20
#   try_it = int(input('\nВведите любое число (0 - для возврата в меню): '))
#   if try_it == 0:
#     mainMenu()
#   else:
#     while try_it != sec_num:
#       print('Не угадал, попробуй еще разок: ', end = '')
#       try_it = int(input())
#       if try_it == 0:
#         mainMenu()
#     else:
#       print('Угадал!!!')
#       print('Игра завершена')

# def mainMenu():
#   while True:
#     print('\nВ какую игру будем играть?')
#     print('\n1 - "Камень, ножницы, бумага" ', '\n2 - "Угадай число" ', '\n0 - Завершить игру', end = '\n' )
#     choice = int(input('\nВыберете игру: '))
#     if choice == 1:
#       rock_paper_scissors()
#     elif choice == 2:
#       guess_the_number()
#     elif choice == 0:
#       print('\nИгра завершена!')
#       break
#     else:
#       print('\nОшибка ввода! Нужно ввести 1, 2 или 3')
#       mainMenu()

# mainMenu()

ппрограмма ищет сначала сумму в диапазоне цифр числа,  а потом сумму цифр в диапазоне полученной суммы (оператор returne
# def summa_n(n):
#   summa = 0
#   for i in range(n+1):
#     summa += i
#   print('Сумма от 1 до', n,'=', summa)
#   return summa


# n = int(input('Введите первое число число: '))

# n = summa_n(n)

# summa_n(n)

Наибольший общий делитель с return и фомулой эвклида. Важно, для того что бы вернуть резултаты функции, нужно назначить новую переменную
и ей присвоить функцию, что бы было куда возвращать значение!!!
# def gcd(a, b):

#   while a != 0 and b != 0:
#     if a > b:
#       a = a % b
#     else:
#       b = b % a
#   gcd = a + b
#   return gcd

# a = int(input('Введите первое число число: '))
# b = int(input('Введите второе число число: '))

# GCD = gcd(a, b)

# print('Наибольший делитель =', GCD)

Вводится последовательность чисел, в ней опеределяется самое длинное число через функцию.
Важно! Всегда переменые для счетчика ставятся перед циклом, иначе они не работают
# def numeralCount (dig):
#   if dig < 0:
#     print('Вы ввели отрицательное значение! Обнуляю!!!')
#     return 0
#   count = 0
#   while dig > 0:
#     dig //= 10
#     count += 1
#   return count

# seq = int(input('Сколько цифр будем вводить? '))
# temp1 = 0
# temp2 = 0

# for num in range(1, seq + 1):
#   print('Введите', num, '-е число: ', end = '')
#   i = int(input())
#   task = numeralCount (i)
#   if task > temp1:
#     temp2 = i
#     temp1 = task

# print('\nПервая задача на обработку:', temp2)

Деление единицы на 2 до нуля + счетчик иттераций
# num = 1
# count = 0
# while num > 0:
#   num /= 2
#   print(num)
#   count += 1
# print('Колличество иттераций: ', count)

Пользователь вводит положительное число x (x > 0). Напишите функцию, которая выводит его в формате плавающей точки, то есть x=a *10 ** b, где 1≤a10.
# def x(n):
#   b = 0
#   if n >= 1:
#     while n > 1:
#       n //= 10
#       b += 1
#     return b - 1
#   elif n < 1:
#     while n < 1:
#       n *= 10
#       b -= 1
#     return b

# while True:
#   n = float(input('\nВведите число N: '))
#   if n ==0:
#     print('\nПрограмма завершена!')
#     break
#   elif n < 0:
#     print('\nОшибка ввода!')
#     print('Число не должно быть меньше 0')
#     n = float(input('\nПовторите ввод: '))

#   a = n / 10 ** x(n)
#   print('\nФормат плавающей точки: x =', a, '* 10 **', x(n))

Проверка ,изменится ли сумма при сложении больших чисел
# def possible (tax, newtax):
#   dif = abs(tax + newtax)
#   if dif > tax +( 1e-15):
#     print('Результат: Бюджет увеличится')
#   else:
#     print('Результат: Бюджет не изменится')

# tax = float(input('Налог: '))
# newtax = float(input('Новый налог: '))

# possible (tax, newtax)

Функция принимает три числа и затем сравнивает сумму первых двух чисел с третьим с определённой степенью точности: до 15-го знака после точки. Если равенство выполняется, то функция возвращает True, иначе возвращает False.
# def eqv():
#   summ = 0
#   for i in range(1, 2+1):
#     print('Введите', i, '-е число: ', end = '')
#     num = float(input())
#     summ += num
#   print(summ)
#   cheksumm = float(input('Введите 3 -e число: '))
#   if abs(cheksumm - summ) < 1e-15:
#     print('True')
#   else:
#     print('False')

# eqv ()

Расчет суммы члена ряда с заданной точностью (Число эллера)
e = 1/0! + 1/1! + 1/2! + 1/3! + .....
# import math

# precision = float(input('С какой точностью считаем: '))

# result = 0
# i = 0
# addMember = 1

# while addMember > precision:
#   addMember = 1 / math.factorial(i)
#   result += addMember
#   i += 1
# print('\n Результат:', result)
# print('Константа:', math.e)

Функция максимума (ищем максимальное из 3х чисел без циклов, оборачиваем в функцию)
# def maxnum():
#   maxnum = (a + b + abs(a-b)) / 2
#   maxnum2 = (maxnum + c + abs (maxnum - c))/ 2
#   return maxnum2

# a = int(input('\nВведите число а: '))
# b = int(input('Введите число b: '))
# c = int(input('Введите число c: '))

# print('\nНаибольшее число:', int(maxnum()))

print('Число наоборот 2') Функция переворачивает числа наоборот, потом суммирует их цифры, потом снова переворачивает и снова суммирует
# def revers(num): #Для вывода числа без нолей
#   n_seq = 0
#   while num:
#     digit = num % 10
#     num //= 10
#     n_seq *= 10
#     n_seq += digit
#   return n_seq

# N = int(input('\nВведите первое число: '))
# K = int(input('Введите второе число: '))

# print('\nПервое число наоборот:', revers(N))
# print('Второе число наоборот:', revers(K))
# print('\nСумма:', revers(N) + revers(K))
# print('Сумма наоборот:', N + K)

На вход подаётся строка — это экспоненциальная форма числа. Пргорамма выводит отдельно мантиссу и отдельно порядок этого числа.
Используется флаг (True/False). Именно он разделяет текст до 'е' и после. И именно он переключается запись символов в переменные!!!

# string = input('Введите число в экспоненциальной форме: ')

# flg = True
# mantissa = ''
# exp = ''
# for sym in string:
#   if sym == 'e':
#     flg = False
#   elif flg:
#     mantissa += sym
#   else:
#     exp += sym

# print('Мантисса:', mantissa)
# print('Порядок:', exp)

('Задача 5. Недоделка 2')Программа меняет первую и последнюю цифру в числе местами, потом суммирует то, что получилось! Обратить внимание на то,
как выделять цифры между
# def chek(num):
#   num_count = 0
#   temp = num
#   while temp > 0:
#     num_count += 1
#     temp //= 10
#   return num_count

# def revers(num):
#   num_count = chek(num)
#   last_digit = num % 10
#   first_digit = num // 10 ** (num_count - 1)
#   between_digits = num % 10 ** (num_count - 1) // 10
#   num = last_digit * 10 ** (num_count - 1) + between_digits * 10 + first_digit
#   return num

# while True:
#   first_n = int(input("\nВведите первое число: "))
#   if chek(first_n) < 3:
#     print('\nВ первом числе меньше трёх цифр. Повторите ввод: ', end = '' )
#   else:
#     second_n = int(input("Введите второе число: "))
#     print()
#     if chek(second_n) < 4:
#       print('Во втором числе меньше четырёх цифр. Повторите ввод:', end = '' )
#       second_n = int(input())
#     print('Первое измененное число:', revers(first_n))
#     print('Второе измененное число:', revers(second_n))
#     print('\nСумма чисел:',revers(first_n) + revers(second_n) )

('Задача 6. Маятник ')
# def demping(start, finish):
#   count = 0
#   while start > finish:
#     step = start * 8.4 / 100
#     count += 1
#     start -= step
#   print('\nМаятник считается остановившимся через', count, 'колебаний')

# while True:
#   initial = float(input('\nВведите начальную амплитуду: '))
#   stop = float(input('Введите амплитуду остановки: '))
#   step = initial * 8.4 / 100
#   if initial < stop or initial < step:
#     print('Ошибка ввода, попробуйте еще раз!')

#   demping(initial, stop)

('Задача 7. Яйца')
D = x**3 − 3x**2 − 12x + 10, где x — глубина кладки в метрах, а D — уровень опасности в условных единицах. На вход программе подаётся максимально допустимое отклонение уровня опасности от нуля, а программа должна рассчитать приблизительное значение "х", удовлетворяющее этому отклонению.
# def f(x):
#   return x ** 3 - 3 * x ** 2 - 12 * x + 10

# while True:
#   x0, x1, e = 0, 4, float(input('\nВведите максимально допустимый уровень опасности: '))
#   if e > 4 or e < 0:
#     print('Превышен уровень опасности! Повторите ввод.')
#   elif e == 0:
#     print('Программа завершена!')
#     break
#   else:
#     while x1 - x0 >= e:
#       D = (x0 + x1) / 2
#       if f(x0) * f(D) < 0:
#         x1 = D
#       else:
#         x0 = D
#     print('\nПриблизительная глубина безопасной кладки:', (x0 + x1) / 2, 'м')

('Задача 8. Сумма ряда')
Пользователь вводит действительное число "х" и точность "precision". Пишем программу которая по число х вычисляет сумму ряда в точности до precision.
         x ** 2      x ** 4      x ** 6        oo                 x ** 2n
формула: -----     +  ----    -   ------  + ... ε   + (- 1) ** n * -----
           2!          4!          6!          n=0                 (2n)!
# def factorial_num(n):
#   factorial = 1
#   for num in range (1, n + 1):
#     factorial *= num
#   return factorial

# def degree_num(x, n):
#   count = 1
#   for num in range (1, n + 1):
#     count = count * x
#   return count

# precision = float(input("Введите точность: "))
# x = int(input("Введите икс: "))
# addMember = 1
# result = 0

# n = 0

# while abs(addMember) > precision:
#   addMember = degree_num(-1, n) * (degree_num(x, (2 * n)) / factorial_num((2 * n)))
#   result += addMember
#   n += 1
# print("Сумма ряда =", result)

('Задача 9. Аннуитетный платёж')
одлежит погашению равными ежегодными выплатами в конце каждого года,включающими процентные платежи и сумму в погашение основного долга. После выплаты третьего платежа продлении срока погашения займа на n_2 лет и увеличении процентной ставки с момента конверсии до i_2%
 Формулы для расчета  A = KS
                     K = i(1 + i) ** n / (1 + i) ** n - 1

# def pay_loan(S, n, i):
#   i = i / 100
#   K = (i * (1 + i) ** n) / ((1 + i) ** n - 1)
#   a_payment = round(K * S, 2)
#   return a_payment

# def period(S, i, a_payment, n):
#   for pay in range(1, int(n) + 1):
#     paid_percent = S * i / 100
#     paid_credit = a_payment - paid_percent
#     print('\nПериод', pay)
#     print('\nОстаток долга на начало периода:', S)
#     print('Выплачено процентов:', paid_percent)
#     print('Выплачено тела кредита:', paid_credit)
#     S -= paid_credit
#   else:
#     print('\nОстаток долга:', S)
#     print('=' * 50)
#     return S

# S = float(input('\nВведите сумму кредита: '))
# n = float(input('На сколько лет выдан? '))
# i = float(input('Сколько процентов годовых? '))

# a_payment = pay_loan(S, n, i)
# new_summ = period(S, i, a_payment, 3)

# new_n = float(input('\nНа сколько лет продляется договор? '))
# new_i = float(input('Увеличение ставки до: '))
# new_year = new_n + n - 3

# a_payment = pay_loan(new_summ, new_year, new_i)
# new_summ = period(new_summ, new_i, a_payment, new_year)

Уравнение прямой, проходящей через две точки, по её координатам: y = k * x + b.
K и b — числа, которые означают угловой коэффициент и вертикальное смещение прямой
# print("Введите первую точку")
# x1 = float(input('X: '))
# y1 = float(input('Y: '))
# print("\nВведите вторую точку")
# x2 = float(input('X: '))
# y2 = float(input('Y: '))
#
# x_diff = x1 - x2
# y_diff = y1 - y2
#
# if x_diff == 0:
#     print('\nНе возможно составить уравнение при Х1 = х2')
#     exit()
#
# k = y_diff / x_diff
# b = y2 - k * x2
#
# print("Уравнение прямой, проходящей через эти точки:")
# print("y = ", k, " * x + ", b)


две функции. Первая принимает одно целое положительное число N и находит сумму всех чисел от одного до N включительно.
Вторая принимает число N и считает количество цифр в числе. В ответ выводится разность суммы чисел и количества.
# def dig_summ(num):
#     summ = 0
#     while num:
#         summ += num % 10
#         num //= 10
#     return summ
#
# def dig_count(num):
#     count = 0
#     while num:
#         count += 1
#         num //= 10
#     return count
#
# num = int(input('Введите число: '))
#
# print('\nСумма чисел:', dig_summ(num))
# print('Количество цифр в числе:', dig_count(num))
# print('Разность суммы и количества цифр:', dig_summ(num) -dig_count(num))


print('Число наоборот 3')
программа переворачивает наоборот целую и дробную часть числа, зате суммирует их
# def revers(n):
#     num = 0
#     while n:
#         num = num * 10 + n % 10
#         n //= 10
#     return num
#
# def separate(seq):
#   flg = True
#   whole = ''
#   part = ''
#   count = 0
#   for sym in seq:
#       if sym == '.':
#           flg = False
#       elif flg:
#           whole += sym
#       else:
#           part += sym
#           count += 1
#   return revers(int(whole)) + revers(int(part)) / int((10 ** count))
#
# string_1 = input('Введите первое число: ')
# string_2 = input('Введите второе число: ')
#
# print('\nПервое число наоборот:', separate(string_1))
# print('Второе число наоборот:', separate(string_2))
# print('Сумма:', separate(string_1) + separate(string_2))

Задача 7. Годы
запрашивается два четырёхзначных числа A и B.
Затем выведите в порядке возрастания все четырёхзначные числа в интервале от A до B,
запись которых содержит ровно три одинаковые цифры.
# def compare(y1, y2):
#   for year in range(y1, y2 + 1):
#     prevSym = ''
#     prevSymCount = 0
#     chek_sym = year % 100 // 10 #для сверки текущего символа с третьей цифрой
#     for letter in str(year):
#       equalSym = False
#       if prevSym == letter:
#         prevSymCount += 1
#       elif letter == str(chek_sym):
#         prevSymCount += 1
#         if prevSymCount == 3:
#           equalSym = True
#           print(year)
#       else:
#         prevSym = letter
#
# year1 = int(input('Введите первый год: '))
# year2 = int(input('Введите второй год: '))
#
# print('\nГоды от', year1, 'до', year2, 'с тремя одинаковыми цифрами:')
# compare(year1, year2)

======================================================================================================================================================================
Работа со списками

С помощью бесконечного цикла программа запрашивает новое число,
закидывает его в конец текущего списка чисел и выводит вторую, третью и четвёртую степень каждого числа текущего списка
# numbers = [3,7,5]

# while True:
#     number = int(input('Новое число: '))
#     numbers.append(number)
#     print('Текущий список чисел:', numbers)
#
#     for i in numbers:
#         print(i ** 2, i ** 3, i ** 4)
#     print()

Напишите программу, которая сначала запрашивает у пользователя количество сотрудников в офисе, ID их пропусков,
а затем запрашивает ID пропуска, который нужно найти в этом списке. Если такой есть,
то вывести «Сотрудник на месте», а иначе «Сотрудник не работает!».
# pass_id = []
#
# quant = int(input('Кол-во сотрудников в офисе: '))
#
# for _ in range(quant):
#     id = int(input('ID сотрудника: '))
#     pass_id.append(id)
#
# check_id = int(input('\nКакой ID ищем? '))
#
# for id in pass_id:
#     if check_id == id:
#         print('\nСотрудник на мсте!')
#         break
# else:
#     print('\nСотрудник не работает!')

print('Урон монстров')
Игра запрашивает количество монстров, номер мага в списке. Маг прибавляет свой урон всем монстрам
Если их урон меньше 100
# monsters_count = int(input('Сколько будет монстров: '))
# mage_index = int(input('Номер мага в списке: '))
# monsters_damage = []
#
# for monster in range(monsters_count):
#     print('Урон у', monster + 1, 'монстра:', end=' ')
#     damage = int(input())
#     monsters_damage.append(damage)
#
# for i_monster in range(monsters_count):
#     if monsters_damage[i_monster] < 100 and i_monster != mage_index - 1:
#         monsters_damage[i_monster] += monsters_damage[mage_index - 1]
#
# print('\nИтоговый урон монстров', monsters_damage)

print('Наименьшее и наибольшее число')
Программа запрашивает количество чисел, сами чилса, и находит наименьшее и наибольшее в них
# nums_list = []
#
# N = int(input('Кол-во чисел в списке: '))
# for _ in range(N):
#     num = int(input('Очередное число: '))
#     nums_list.append(num)
#
# maximum = nums_list[1]
# minimum = nums_list[1]
#
# for i in nums_list:
#     if maximum < i:
#         maximum = i
#     if minimum > i:
#         minimum = i
#
# print('Максимальное число в списке:', maximum)
# print('Минимальное число в списке:', minimum)

Пользователь вводит список из N чисел и число K. Код, выводящий на экран сумму индексов элементов списка,
которые кратны K.
# nums_list = []
#
# N = int(input('Кол-во чисел в списке: '))
#
# for i in range(N):
#     print('Введите', i + 1,'число:', end=' ')
#     num = int(input())
#     nums_list.append(num)
#
# divider = int(input('\nВведите делитель: '))
#
# index_summ = 0
# for i_nums in range(N):
#     if nums_list[i_nums] % divider == 0:
#         index_summ += i_nums
#         print('\nИндекс числа', nums_list[i_nums], ':', i_nums )
#
# print('Сумма индексов:', int(index_summ))

Дан список очков из N собак. Напишите программу, которая меняет местами наибольший и наименьший элементы в списке.
Важно!!!! Первый элемент списка всегда с индксом = 0, последний элемент в таком случае будет иметь индекс -1
# dog_scores = []
# sorted_dog_scores = []
#
# N = int(input('Кол-во собак: '))
#
# for i in range(N):
#     print('Введите кол-во очков', i + 1,'собаки:', end=' ')
#     score = int(input())
#     dog_scores.append(score)
#
# dog_scores[0], dog_scores[-1] = dog_scores[-1], dog_scores[0]
# print(dog_scores)

Заменяем символ в слове, по выбору пользователя
Важно!!! Используется функция list
# word = input('Введите слово: ')
# replace_num = int(input('Введите номер символа для замены: '))
# replace_sym = input('На что меняем: ')
#
# sym_list = list(word) #переводит слово в список посимвольно. Не работает с цифрами!!!
# sym_list[replace_num - 1] = replace_sym
#
# for i in sym_list:
#     print(i, end='')

Улучшенная лингвистика
Подсчет слов в тексте
# word_list = []
# count = [0, 0, 0]
# for i in range(3):
#     print('Введите', i + 1, 'Слово:', end=' ')
#     word = input()
#     word_list.append(word)
#
# text = input('Слово из текста: ')
#
# while text != 'end':
#     for index in range(3):
#         if word_list[index] == text:
#             count[index] += 1
#     text = input('Слово из текста: ')
#
# print('\nПодсчет слов в тексе')
# for i in range(3):
#     print(word_list[i], ':', count[i])

Заменеяем символы в целой строке
# string = input('Введите строку: ')
# new_string = []
#
# sym_list = list(string) #переводит словов список посимвольно. Не работает с цифрами!!!
# replace_sym = ';'
#
# count = 0
# for sym in sym_list:
#     if sym == ':':
#         sym = replace_sym
#         count += 1
#     new_string.append(sym)
#
# print('Измененная строка: ', end='')
# for sym in new_string:
#     print(sym, end='')
#
# print('\nКол-во замен:', count)

Дана строка S и номер позиции символа в строке. Программа выводит соседей этого символа
и сообщение о количестве таких же символов среди этих соседей
# string = input('Введите строку: ')
# chek_sym = int(input('Номер символа: '))
#
# sym_list = list(string) #переводит слово в список посимвольно. Не работает с цифрами!!!
#
# count = 0
# for sym in sym_list:
#     if sym == sym_list[chek_sym - 1]:
#         count += 1
#
# print('\nСимвол справа:', sym_list[chek_sym])
# print('Символ слева:', sym_list[chek_sym-2])
#
# if count == 2:
#     print('\nЕсть ровно один такой же символ.')
# elif count > 2:
#     print('\nЕсть', count, 'таких же символов.')
# else:
#     print('\nТаких же символов нет.')

Код добавляет очки 1 и 3 игроку из списка. Для подсчета списка исполльзуется len()
# scores = [8, 5, 10, 7, 6]
# scores[1] += len(scores)
# scores.append(0)
# scores[2] += len(scores)
# print(scores)

На вход получаем число и в его диапазоне формируем списко из нечетных чисел
# N = int(input('Введите число: '))
# number = []
# for num in range(1, N + 1):
#     if num % 2 != 0:
#         number.append(num)
# print('Список из нечётных чисел от 1 до', N, ':', number)

Формируем список участников, только с четным индексом
# names_list = ["Артемий", "Борис", "Влад", "Гоша", "Дима", "Евгений", "Женя", "Захар"]
# new_names_list = []
#
# for i_names in range(len(names_list)):
#     if i_names % 2 == 0:
#         new_names_list.append(names_list[i_names])
#
# print(new_names_list)

Задача 3. Клетки
Программу выводит на экран те элементы списка, значения которых меньше их индекса
# cells_list = [3, 0, 6, 2, 10]
# inappropriate_cells_list = []
#
# for i_cells in range(len(cells_list)):
#     if cells_list[i_cells] < i_cells:
#         inappropriate_cells_list.append(cells_list[i_cells])
# print('Кол-во клеток:', len(cells_list))
# for i in range(len(cells_list)):
#     print('Эффективность', i + 1, 'клетки:', cells_list[i])
# print('\nНеподходящие значения:', inappropriate_cells_list)

Программа, которая удаляет из списка видеокарт наибольшие элементы.
# old_list = [3070, 2060, 3090, 3070, 3090]
# new_list = []
# maximum = old_list[1]
#
# for i_card in old_list:
#     if maximum < i_card:
#         maximum = i_card
# for i_card in old_list:
#     if i_card < maximum:
#         new_list.append(i_card)
#
# print('Кол-во видеокарт:', len(old_list))
# for i in range(len(old_list)):
#     print(i + 1, 'Видеокарта:', old_list[i])
# print('\nСтарый список видеокарт:', old_list)
# print('Старый список видеокарт:', new_list)

Получаем список фильмов от пользователя, сравниваем с ттем, что есть. Выводим спсок того что получилось
И ошибки.
Важно!!!! Что бы сравнить текстовые списки (строки) - нужно использывать функцию in а не '=='
# available_films = [
#         "Крепкий орешек", "Назад в будущее", "Таксист",
#         "Леон", "Богемская рапсодия", "Город грехов",
#         "Мементо", "Отступники", "Деревня"
#     ]
#
# new_favorite_films = []
# quant = int(input('Сколько фильмов хотите добавить? '))
# errors = []
#
# for _ in range(quant):
#     add_favorite_film = input('Введите название фильма: ')
#     if add_favorite_film in available_films:
#         new_favorite_films.append(add_favorite_film)
#     else:
#         errors.append(add_favorite_film)
#
# for i in range(len(errors)):
#     print('Ошибка: фильма ', errors[i], 'у нас нет :(')
# print('Ваш список любимых фильмов:', new_favorite_films)

Анализ слова
Програма считает количество уникальных символов в слове
# word = input('Введите слово: ')
# number_unique_letters = 0
#
# for sym in word:
#     repeat = 0
#     for i in word:
#         if sym == i:
#             repeat += 1
#     if repeat == 1:
#         number_unique_letters += 1
#
# print('Кол-во уникальных символов:', number_unique_letters)

Контейнеры
получает на вход невозрастающую последовательность натуральных чисел, означающих массу каждого контейнера в ряду.
После этого вводится число X – масса нового контейнера. Программа выводит номер, под которым будет лежать новый контейнер.
Если в ряде есть контейнеры с одинаковой массой, таким же, как у нового, то его нужно положить после них.
# case_quant = int(input('Кол-во контейнеров: '))
# list_container_weights = []
#
# for _ in range(case_quant):
#     container_weights = int(input('Введите вес контейнера: '))
#     if container_weights > 200:
#         print('Число должно быть целым и не должно превышать 200')
#         print('Повторите ввод: ', end=' ')
#         container_weights = int(input())
#     else:
#         list_container_weights.append(container_weights)
# new_container_weight = int(input('Введите вес нового контейнера: '))
#
#
# serial_number_new_container = 0
# new_container_list = []
#
# for x in list_container_weights:
#     if x >= new_container_weight:
#         new_container_list.append(x)
#         serial_number_new_container += 1
#     else:
#         new_container_list.append(new_container_weight)
#         serial_number_new_container += 1
#         print(serial_number_new_container)
#         break

Бегущая строка
Дан список из N элементов и целое число K. Программа, которая циклически сдвигает элементы списка вправо на K позиций.
# original_list = []
# shifted_list = []
#
# for _ in range(5):
#     N = int(input('Введите элемент списка: '))
#     original_list.append(N)
# shift = int(input('Сдвиг: '))
#
# for i in range(len(original_list)):
#     shifted_list.append(original_list[i - shift])
#
# print('Изначальный список:', original_list)
# print('Сдвинутый список:', shifted_list)

Анализ слова 2 (Палиндром). Проверяфем слово палиндром или нет (читается одинково слева направо и наоборот)
# word = input('Введите слово: ')
# check_list = list(word)
# revers_list = []
#
# for char in range(len(word), 0, -1):
#     revers_list.append(word[char - 1])
# if check_list == revers_list:
#     is_palindrome = True
# else:
#     is_palindrome = False
# if is_palindrome:
#     print('Слово является палиндромом')
# else:
#     print('Слово не является палиндромом')
# pass

Важно! Сортировка
Сортируем список методом выбора (попарно сравниваем числа по всему списку в двух циклах)
# original_list = []
#
# quant = int(input('Сколько будет чисел? '))
# for i in range(quant):
#     print('Введите', i + 1, 'число:', end=' ')
#     dig = int(input())
#     original_list.append(dig)
#
# for check in range(len(original_list)):
#     for dig in range(check, len(original_list)):
#         if original_list[dig] < original_list[check]:
#             original_list[dig], original_list[check] = original_list[check], original_list[dig]
# print('Отсортированный список:', original_list)
========================================================================================================================
Методы! (функции)
Добавляем элемент в список с выбором места добавления
# langs = ['Python', 'Java', 'JS', 'SQL']
# user_langs = input('После чего вставить: ') # Запрашиваем место в списке, куда (после какого элемента) вставить новый элемент.
# # Пользователь прям вводит название элемента
#
# i_langs = langs.index(user_langs) # С помощью 'index', в скобках указываем обЪет списка, который ищем.
# # (по сути, так же как и обращение к append через '.') А в переменную записывается его индекс из списка
#
# langs.insert(i_langs + 1, 'C++') # Добавляем элемент ('C++', используя полученную переменную, не забываем про '+1',
# # так как хотим добавить после указанного пользователем элемента
#
# print(langs)

Рейтинг кино
Используются новые методы: insert, remove
# def is_film_exist(movie, films_list):
#     for i_movie in films_list:
#         if i_movie == movie:
#             return True
#     return False
#
# available_films = [
#         "Крепкий орешек", "Назад в будущее", "Таксист",
#         "Леон", "Богемская рапсодия", "Город грехов",
#         "Мементо", "Отступники", "Деревня", "Матрица"
#     ]
# my_list = []
#
# while True:
#     print('\nВаш текущий топ фильмов:', my_list)
#     new_movie = input('Введите название фильма: ')
#     if is_film_exist(new_movie, available_films):
#         print('Команды: добавить, удалить, вставить')
#         command = input('Введите команду: ')
#         if command == 'добавить':
#             my_list.append(new_movie)
#         if command == 'удалить':
#             if is_film_exist(new_movie, my_list):
#                 my_list.remove(new_movie)
#             else:
#                 print('Такого фильма нет в нашем рейтинге')
#         if command == 'вставить':
#             index = int(input('На какое место? '))
#             my_list.insert(index - 1, new_movie)
#
#     else:
#         print('Такого фильма нет на сайте!')

Зоопарк: добавляем и удаляем из списка животных, выводим список с ними и номера клеток по индексу
# zoo = ['lion', 'kangaroo', 'elephant', 'monkey']
#
# zoo.insert(1, 'bear')
# zoo.remove('elephant')
#
# print('Зоопарк:', zoo)
# print('Лев сидит в клетке номер:', zoo.index('lion') + 1)
# print('Обезьяна сидит в клетке номер:', zoo.index('monkey') + 1)

Зарплаты:
Добавляем в список зарплаты, равные 0 удаляем из списка и выводи итоговый список
Используются новые методы max и min
# salary_list = []
#
# quant = int(input('Кол-во сотрудников: '))
# for i in range(quant):
#     print('Зарплата', i + 1, 'сотрудника:', end=' ')
#     salary = int(input())
#     salary_list.append(salary)
#     if salary == 0:
#         salary_list.remove(0)
#
# print('\nОсталось сотрудников:', len(salary_list))
# print('Зарплаты:', salary_list)
# print('\nМинимальная зарплата:', min(salary_list))
# print('Минимальная зарплата:', max(salary_list))

Пакетная передача данных: считаем кол-во ошибок в пакете, отбрасываем битые, выводим иотговое сообщение
Используется метод .extend
# pack = []
# decode = []
# bad_pack = 0
#
# pack_amt = int(input('Кол-во пакетов: '))
# for i_pack_num in range(pack_amt):
#     print('\nПакет номер', i_pack_num + 1)
#     for i_bit in range(4):
#         print(i_bit + 1, 'бит:', end=' ')
#         num = int(input())
#         pack.append(num)
#     if pack.count(-1) <= 1: # .count - считает необходимые элементы в списке (их указываем в скобках)
#         decode.extend(pack) # .extend - расширяет список (то есть можно добавить один список в другой), что бы добавить простой элемент, используется append
#     else:
#         print('Слишком много ошибок!')
#         bad_pack += 1
#     pack = []
#
# print('\nПолученное сообщение', decode)
# print('Кол-во ошибок в сообщении: ', decode.count(-1))
# print('Кол-во потерянных пакетов:', bad_pack)

Программа считает оличество специальных символов ! и ?. Если в первой строке их больше, чем во второй - добавляет вторую к первой и наоборот
Что бы посчитать количество символов - нужно внести строчку посимвольно в список (можно через .extend или через list())
# print_list = []
#
# str_1 = input('Первое сообщение: ')
# list_1 = list(str_1)
# str_2 = input('Второе сообщение: ')
# list_2 = list(str_2)
#
# if list_1.count('!') > list_2.count('?'):
#     print_list.append(str_1)
#     print_list.append(str_2)
#     print('Третье сообщение:', print_list)
# elif list_2.count('?') > list_1.count('!'):
#     print_list.append(str_2)
#     print_list.append(str_1)
#     print('Третье сообщение:', print_list)
# else:
#     print('Ой')
========================================================================================================================
Вложенные списки
list Вместо цикла. Можно использовать лист вместо цикла for, если нужно заполнить список числами в каком-то диапазоне
# N = int(input('Кол-во участников: '))
# members = list(range(1, N + 1))
# print('Список участников:', members)

Создать вложенные списки в основном списке и вывести вложенные списки по отдельности (по примеру распечатки таблицы умножения)
# members = []
# N = int(input('Кол-во участников: '))
# K = int(input('Кол-во человек в команде: '))
#
# num = 1
# if N % K != 0:
#     print(N, 'участников невозможно поделить на команды по', K, 'человек!')
# else:
#     for _ in range(N // K): # делаем цикл, что бы создать нужное кол-во списков разделив N на K (участников на кол-во их в группе)
#         members.append(list(range(num, num + K))) # заполняем вложенные списки в указанном диапазоне
#         num += K # меням точку отсчета для цикла, что бы не добавлялись одни и те же цифры во вложенный список
#     print('\nОбщий список команд:', members) # печатаем получившийся список
#
# for i_team in members:
#     print('Команда', i_team) # Печатаем вложенные списки по отдельности

Распечатать список без скобок и запятых
# members = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
# for i_team in members:
#  for i_man in i_team:
#      print(i_man, end=' ')
#  print()

Подсчет слов в тексте, с использование вложенных списков
# words_list = [['', 0], ['', 0], ['', 0]]
#
# for i_nums in range(3):
#     print('Введите', i_nums + 1, 'Слово:', end=' ')
#     word = input()
#     words_list[i_nums][0] = word # Вторыми скобками рядом с [i_nums], мы обращаемся к элементу вложенного списка
#
# text = input('Слово из текста: ')
#
# while text != 'end':
#     for index in range(3):
#         if words_list[index][0] == text:
#             words_list[index][1] += 1
#     text = input('Слово из текста: ')
#
# print('\nПодсчет слов в тексте')
# for i in range(3):
#     print(words_list[i][0], ':', words_list[i][1])

Лавка. Код, который добавляет в список goods ещё один список с новым фруктом и ценой (это запрашивается у пользователя),
а затем увеличивает цены всех фруктов на 8%.
# goods = [["яблоки", 50], ["апельсины", 190], ["груши", 100], ["нектарины", 200], ["бананы", 77]]
# fruit = input('Название фрукта: ')
# price = int(input('Цена: '))
#
# goods.append([fruit,price]) # Так добавляется ВЛОЖЕННЫЙ список (с двумя и более аргументами), для этого просто используются []

# for item in goods:
#     item[1] = round(item[1] * 1.08, 2)
#
# print('Новый ассортимент:', goods)

В основной список закидывается до список, считается 5ки, потом 5ки удаляются, закидывается второй список, там считаются 3ки
Петчатается итоговый список
# a = [1, 5, 3]
# b = [1, 5, 1, 5]
# c = [1, 3, 1, 5, 3, 3]
#
# a.extend(b)
# print('Кол-во цифр 5 при первом объединении:', a.count(5))
#
# for i in a:
#     if i == 5:
#         a.remove(5)
# a.extend(c)
#
# print('Кол-во цифр 3 при втором объединении:', a.count(3))
# print('Итоговый список: ', a)

Детали: программуа, которая запрашивает у пользователя деталь, считает их количество, а также общую стоимость.
# def parts_count(quantity):
#     count = 0
#     for i_parts in range(len(shop)):
#         if shop[i_parts][0] == part:
#             count += 1
#     return count
#
# def parts_price(stock):
#     summa = 0
#     for i_parts in range(len(shop)):
#         if shop[i_parts][0] == part:
#             summa += shop[i_parts][1]
#     return summa
#
# while True:
#     shop = [['каретка', 1200], ['шатун', 1000], ['седло', 300],
#             ['педаль', 100], ['седло', 1500], ['рама', 12000],
#             ['обод', 2000], ['шатун', 200], ['седло', 2700]]
#
#     part = input('\nНазвание детали: ')
#     print('Кол-во деталей —', parts_count(shop))
#     print('Общая стоимость —', parts_price(shop))

Вечеринка. В списке гоостей всего 6 мест. Программа спрашивает имя и действие (добавить/удалить участника)
# guests = ['Петя', 'Ваня', 'Саша', 'Лиза', 'Катя']

# while True:
#     print('\nСейчас на вечеринке', len(guests), 'человек:', guests)
#     status = input('Гость пришёл или ушёл? ')
#     if status == 'ушёл':
#         g_name = input('Имя гостя: ')
#         guests.remove(g_name)
#         print('Пока,', g_name, '!')
#     elif status == 'пришёл':
#         g_name = input('Имя гостя: ')
#         if len(guests) >= 6:
#             print('Прости,', g_name, 'но мест нет.')
#         else:
#             guests.append(g_name)
#             print('Привет,', g_name,'!')
#     elif status == 'Пора спать':
#         print('Вечеринка закончилась, все легли спать.')
#         break

Песни. Программа ищит треки в списке и считает их общую длительность
# violator_songs = [
#     ['World in My Eyes', 4.86],
#     ['Sweetest Perfection', 4.43],
#     ['Personal Jesus', 4.56],
#     ['Halo', 4.9],
#     ['Waiting for the Night', 6.07],
#     ['Enjoy the Silence', 4.20],
#     ['Policy of Truth', 4.76],
#     ['Blue Dress', 4.29],
#     ['Clean', 5.83]
# ]
#
# quant = int(input('Сколько песен выбрать? '))
# playlist_duration = 0
#
# for i_track in range(quant):
#     print('Название', i_track + 1, '-й песни:', end=' ')
#     song = (input())
#     for i_song in range(len(violator_songs)):
#         if violator_songs[i_song][0] == song:
#             playlist_duration += violator_songs[i_song][1]
#
# print('\nОбщее время звучания песен:', round(playlist_duration, 2))

Ролики: N размеров коньков и K размеров ног людей. код определяет, сколько человек сможет одновременно взять ролики
# skates = []
# people = []
#
# q_skates = int(input('Кол-во коньков: '))
# for i in range(q_skates):
#     print('Размер', i + 1, '-й пары:', end=' ')
#     pair = int(input())
#     skates.append(pair)
#
# q_people = int(input('\nКол-во людей: '))
# for i in range(q_people):
#     print('Размер', i + 1, '-го человека:', end=' ')
#     size = int(input())
#     people.append(size)
#
# count = 0
# for size in people:
#     if size in skates:
#         count += 1
#         skates.remove(size)
#
# print('\nНаибольшее кол-во людей, которые могут взять ролики:', count)

Считалка:начинают играть в считалку на выбывание, где каждый K-й по счёту человек выбывает из круга,
после чего счёт продолжается со следующего за ним человека.
# n = int(input('Кол-во человек: '))
# k = int(input('Какое число в считалке? '))
# print('Значит, выбывает каждый', k, '-й человек')
#
# p_list = list(range(1, n + 1))
# counter = 0
#
# while len(p_list) > 1:
#     print('\nТекущий круг людей:', p_list)
#     if len(p_list) == counter:
#         counter = 0
#     print('Начало счёта с номера', p_list[counter])
#     counter = (counter + (k - 1)) % len(p_list)
#     print('Выбывает человек под номером', p_list[counter])
#     p_list.remove(p_list[counter])
# else:
#     print('\nОстался человек под номером', p_list[0])

Задача 9. Друзья: Сначала вводится число N — количество друзей, затем вводится число K — количество долговых расписок, после этого следует
K троек чисел: номер друга, взявшего в долг, номер друга, давшего деньги, и сумма.
# N = int(input('Кол-во друзей: '))
# K = int(input('Долговых расписок: '))
# friends_list = []
#
# for _ in range(N):
#     friends_list.append(0)
#
# for number in range(K):
#     print("\n", number + 1, '- я расписка: ')
#     to_who = int(input('Кому: '))
#     from_who = int(input('От кого: '))
#     how_much = int(input('Сколько: '))
#     friends_list[from_who - 1] += how_much
#     friends_list[to_who - 1] -= how_much
#
# print('\nБаланс друзей: ')
# for index in range(len(friends_list)):
#     print(index + 1, ": ", friends_list[index])

Симметричная последовательность. Пользователь вводит последовательность из N чисел. Программа определяет,
какое минимальное количество и каких чисел надо приписать в конец этой последовательности, чтобы она стала симметричной.
(одинаково читалась слева направо и наоборот)
# def nums_check(n_list):
#     r_list = []
#     for i_num in range(len(n_list) - 1, -1, -1):
#         r_list.append(n_list[i_num])
#     if n_list == r_list:
#         return True
#     else:
#         return False
#
# nums = []
# new_nums = []
# answer = []
#
# q_nums = int(input('Кол-во чисел: '))
# for _ in range(q_nums):
#     num = int(input('Число: '))
#     nums.append(num)
#
#
# for i_nums in range(0, len(nums)):
#     for sub_num in range(i_nums, len(nums)):
#         new_nums.append(nums[sub_num])
#     if nums_check(new_nums):
#         for i_answer in range(0, i_nums):
#             answer.append(nums[i_answer])
#         answer.reverse()
#         break
#     new_nums = []
#
# print('\nПоследовательность: ', nums)
# print('Нужно приписать чисел:', len(answer))
# print('Сами числа:', answer)

List comprehensions
=========================================================================================================================
Возведение в квадрат и в куб. Возводим в квадрат и куб в установленных границах  циклом внутри списка
# l_border = int(input('Левая граница: '))
# r_border = int(input('Правая граница: '))
#
# squer_list = [x ** 2 for x in range(l_border, r_border)] # x ** 2 - выражение, х - переменная цикла, range(l_border, r_border) - итерируемый объект
# qube_list = [x ** 3 for x in range(l_border, r_border)]
#
# print('Список квадратов чисел в диапазоне от', l_border, 'до', r_border, ':', squer_list)
# print('Список кубов чисел в диапазоне от', l_border, 'до', r_border, ':', qube_list)

Использоваие условий (if) в list comprehension
Важно! Если планируем использовать else, то условия ствятся вначале, сразу после выражения (x ** 2), если нужно просто отфильтровать елементы,
например только не четные (x % 2 != 0), то условие (if), ставится в конце
# squer_odds = [x ** 2 for x in range (10) if x % 2 != 0] # Возводим в квадрат только нечетные числа
# squer_cubes = [(x ** 2 if x % 2 !=0 else x ** 3) for x in range(10)] # Возводим нечетные в квадрат, а четные в куб (использем else)

Повышение каждый год: Запрашиваем процент повышение на каждый год, используем функцию внутри списка
# def get_higher_price (percent, price):
#     return round(price * (1 + percent / 100), 2) # Так расчитывается повыешение в процентах
#
# price_now = [1.09, 25.56, 57.84, 4.56, 6.78]
# first_percent = int(input('Повышение на первый год: '))
# second_percent = int(input('Повышение на второй год: '))
#
# first_price = [get_higher_price(first_percent, i_price) for i_price in price_now]
# second_price = [get_higher_price(second_percent, i_price) for i_price in first_price]
#
# print('Сумма цен за каждый год:', round(sum(price_now), 2), round(sum(first_price), 2), round(sum(second_price), 2))

Удваиваем символы в строке и склеиваем с доп символом
# string = input('Введите строку: ')
# symbol = input('Введите дополнительный символ: ')
#
# d_string = [x * 2 for x in string]
# sym_string = [x + symbol for x in d_string]
#
# print('Список удвоенных символов:', d_string)
# print('Склейка с дополнительным символом:', sym_string)

Отряды: Генерируем два списка с помощью random, Юнит третьего отряда погибает, если сумма урона от двух монстров больше 100.
# import random
#
# squad_1 = [random.randint(50, 80) for _ in range(10)]
# squad_2 = [random.randint(30, 60) for _ in range(10)]
# squad_3_condition = [('Погиб' if squad_1[i_damage] + squad_2[i_damage] > 100
#                       else 'Выжил')
#                      for i_damage in range(10)]
# print('\nУрон первого отряда:', squad_1)
# print('Урон второго отряда:', squad_2)
# print('Состояние третьего отряда:', squad_3_condition)
# print('\nВыживших:', squad_3_condition.count('Выжил'))
# print('Погибших:', squad_3_condition.count('Погиб'))

Генерируем список только четных чисел в заданном диапазоне
# l_border = int(input('Начало диапазона: '))
# r_border = int(input('Конец диапазона: '))
#
# even_list = [x  for x in range(l_border, r_border) if x % 2 == 0]
# print(even_list)

Магазин. Программа генерирует новый список из первого списка, заменяя все отрицательные числа на ноль
# original_prices = [1.25, -9.45, 10.22, 3.78, -5.92, 1.16]
# new_prices = [(x if x > 0 else 0) for x in original_prices]
# print(new_prices)
========================================================================================================================
Срезы:
nums = new_nums[:] - Так создается копия списка
nums = new_nums[2:6] - так берутся элементы списка от 2 до 5-го например. Это и называется "Срез"
nums[2:5:1] - по аналогии с range: есть страт(2), стоп(5), и шаг(1).
nums = [::2] Если идем сначала - можноо не писать 0, и если идем до конца списка то  так же ноль не указываем, только шаг
Как и в range шаг может быть -1. Тогда перевернется список (nums = [::-1])
nums[:3] = 1,1,1 - так меняется элемент прямо внутри списка, без доп переменных (так заменятся элементы с 0 по 2)
nums[:3] = 1 - а так 1 встанет вместо трех элементов сразу (с 0 по 2) и список сократится

Примеры срезов:
# nums = [48, -10, 9, 38, 17, 50, -5, 43, 46, 12]

# print(nums[:]) # Копия строки
# print(nums[:5]) # Первые пять элементов
# print(nums[:-2]) # Все элементы кроме последних двух
# print(nums[::2]) # Только четные индексы списка
# print(nums[1::2]) # Только Нечетные индексы списка
# print(nums[::-1]) # Список в обратном порядке
# print(nums[-1::-2]) # Все элементы списка через один в обратном порядке, начиная с последнего.
# print(nums[-1::]) # Все элементы начиная с конца до предпоследнего.
# print(nums[3:4:]) # Все элементы в диапазоне индексов от 3 до 4 (не включая 4).
# print(nums[-3::]) # Последние три элемента строки.
# print(nums[3:5:]) # Все элементы в диапазоне индексов от 3 до 4.
# print(nums[4:2:-1]) # То же, что и в предыдущем пункте, но в обратном порядке.

Анализ цен. Программа получаетс псисок, делает его копию, заменяет все отрицательные на ноль, считает сумму отрицуательных
# import random
# original_prices = [random.randint(-10, 10) for _ in range(10)]
# new_prices = original_prices[:]
#
# for i in range(len(original_prices)):
#     if new_prices[i] < 0:
#         new_prices[i] = 0
# print("Мы потеряли: ",  sum(original_prices) - sum(new_prices))

Программа удаляет элементы списка с индексами от А до В. Не используйте дополнительные переменные и методы списков.
# import random
#
# nums = [48, -10, 9, 38, 17, 50, -5, 43, 46, 12]
# a = random.randint(0, len(nums) - 1)
# b = random.randint(a, len(nums))
# nums[a:b] = ''
#
# print('A:', a)
# print('B:', b)
# print(nums)

Симметричная последовательность. Со срезами
# def nums_check(n_list):
#     r_list = n_list[::-1]
#     if n_list == r_list:
#         return True
#     else:
#         return False
#
# nums = []
# answer = []
#
# q_nums = int(input('Кол-во чисел: '))
# for _ in range(q_nums):
#     num = int(input('Число: '))
#     nums.append(num)
#
#
# for i_nums in range(0, len(nums)):
#     if nums_check(nums[i_nums:len(nums)]):
#         answer = nums[:i_nums]
#         answer.reverse()
#         break
#
# print('\nПоследовательность: ', nums)
# print('Нужно приписать чисел:', len(answer))
# print('Сами числа:', answer)

Срезы в строках: Программа делит слово пополам, переворачивает каждую часть и склеивает заново
Важно!!! В строках менять данные внутри нельзя, в отличии от списков. Только переприсваивать их другим переменным
# word = 'Привет'
#
# first_part = word[:len(word) // 2]
# print(first_part[::-1])
#
# second_part = word[len(word) // 2:]
# print(second_part[::-1])
#
# print(first_part[::-1] + second_part[::-1])

Программа которая запрашивает у пользователя текст и генерирует список из гласных букв этого текста (сама строка вводится на русском языке).
Выведите в консоль сам список и его длину.
# letters = "аоиеёэыуюя"
#
# text = input("Введите текст: ")
# vowel = [char for char in text if char in letters]
# print("Список гласных букв:", vowel)
# print("Длина списка:", len(vowel))

Задача 2. Генерация. Программа генерирует список из N чисел, на чётных местах в нём стоят единицы, а на нечётных — числа,
равные остатку от деления своего номера на 5.

# print('Результат:', [x % 5 if x % 2 else 1 for x in range(int(input('Введите длину списка: ')))])

Случайные соревнования: Генерируются два списка вещественных чисел. В третий попадают наибольшие из двух списков
# import random
#
# team1 = [round(random.uniform(5, 10), 2) for x in range(21)] #Для генерации вещественных чисел м плавающей точкой - используется (random.uniform)
# team2 = [round(random.uniform(5, 10), 2) for x in range(21)]
# vinner_list = [team1[i_team] if team1[i_team] > team2[i_team]
#                else team2[i_team] for i_team in range(21)]
#
# print('\nПервая команда:', team1)
# print('Вторая команда:', team2)
# print('Победители тура:', vinner_list)

Задача 5. Разворот. Вводится строка. В ней обязательно минимум 2 одинаковых буквы (например 'h'). Программа находит первую,
переворачивает все что идет дальше и останавливается после 'h', которая встретится ВПОСЛЕДНИЙ раз!!! То есть 'h' может
встречаться сколько угодно раз в строке, но цикл остановится именно перед последней!!!
# string = input('Введите строку: ')
# answer = []
#
# for i_char in range(len(string)):
#     if string[i_char] == 'h': # Важно!!! цикл не только начинается если встретит 'h', но и закончится!! как только встретит оследнюю 'h' в строке
#         answer = string[1:i_char]
#
# print('Развёрнутая последовательность между первым и последним h: ', answer[::-1])

Задача 6. Сжатие списка. Переставляет все 0 в конец массива. При этом все ненулевые элементы располагаются в начале массива
в том же порядке. Затем все 0 из списка удаляются.
# import random
# n = int(input('Количество чисел в списке: '))
#
# n_list = [random.randint(0, 2) for x in range(n + 1)]
#
# print('Список до сжатия:', n_list)
# print('Список после сжатия:', [x for x in n_list if x > 0])

Задача 7. Двумерный список. Должно получиться:[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
Можно использовать только list comprehensions
# step = 4 # Отвечает за количество вложенных списков
# result = [list(range(x, (x + step) * 2, step)) for x in range(1, step + 1)] # Важно! Если в range указан диапазон стоп и шаг, то последня цифра диапазона в список не входит
#
# print(result)

Задача 8. Развлечение. На вход количество палок N и количество бросков K. Далее идёт K пар чисел Left_i, Right_i,
при этом 1 ≤ Left_i ≤ Rig. Выводится последовательность сбитых и оставшихся палок.
# import random
#
# n = int(input('Количество палок: '))
# k = int(input('Количество бросков: '))
#
# answer = ['I' for _ in range(n)]
#
# for i_hit in range(k):
#     Right_i = random.randint(1, n)
#     Left_i = random.randint(1, Right_i)
#     print('Бросок', i_hit + 1, '.')
#     print('Сбиты палки с номера', Left_i, '\nпо номер', Right_i, '.')
#     answer[Left_i - 1:Right_i] = '.' * ((Right_i - Left_i) + 1)
#
# print('\nРезультат:', end=' ')
# for sym in range(len(answer)):
#         print(answer[sym], end='')

Задача 9. Список списков. Нужно раскрыть все вложенные списки, используя только list comprehensions
# nice_list = [[[1, 2, 3], [4, 5, 6], [7, 8, 9]],
#              [[10, 11, 12], [13, 14, 15], [16, 17, 18]]]
#
# print('Ответ:', [sym for sub_list2 in nice_list for sub_list in sub_list2 for sym in sub_list])

Задача 10. Шифр Цезаря. Вводится строка и сдиг. Каждая буква заменяется на следующую по алфавиту через сдвиг (например 3))
тогда буква 'А', становится буквой 'Г' и т.д.
# def char_find(user_text, user_shift):
#     cipher_list = [(letters[(letters.index(sym) + user_shift) % len(letters)]) # Тут берем букву из строки юзера с помощью .index
#                    if sym != ' ' else ' ' for sym in user_text]
#     new_list = ''.join(cipher_list)
#     return new_list
#
# letters = 'абвгдеёжзийклмнопрстуфхцчшщъыьэюя'
# original_list = list(input('Введите сообщение: ').lower())
# shift = int(input('Сдвиг: '))
#
# cifer_text = char_find(original_list, shift)
#
# print('Зашифрованное сообщение: ', cifer_text)

========================================================================================================================
Коллекция: Строки. Format. Есть два варианта присвоения значений
Либо по самому элементу строки либо по индексу элемента (то есть по порядку, как в функции). Для отметки используются {}
Что бы использовать переменные несколдько раз - просто добавляем ключь (например {0}) в нужное место строки

names_list = input().split() - разделяем строку на элементы и удаляем лишние пробелы
peoplre_str = ', '.join(people) - соединяем элементы в строку

Путь к файлу
# user_name = input('Имя пользователя: ')
# file_name = input('Имя файла: ')
#
# path = 'C/{user}/docs/folder/{new_file}.txt'.format( # Так присваиваем значения конкретному элементу
#     user=user_name,
#     new_file=file_name
# )
#
# path2 = 'C/{0}/docs/folder/{1}.txt'.format( # А так присваиваем по порядку
#     user_name,
#     file_name
# )
# path3 = f'C/{user_name}/docs/folder/{file_name}.txt'  # А это метод f-string. В начале строки просто ставим f

# print('Путь к файлу:', path)

Шаблон поздравления!
# while True:
#     grats_template = input('Введите шаблон поздравления'
#                            'в шаблоне нужно использовать конструкцию {name} и {age}: ')
#     if '{name}' in grats_template and '{age}' in grats_template:
#         break
#     print('Ошибка: Отсутствует конструкция {name}!')
#
# names_list = input('Список людей через запятую: ').split(', ') # В скобках указываем, что для split служит разделителем
# ages_str = input('Возраст людей через пробел: ') # Тут мы вводим цифры как строку, т.к. split работает только со строками
# ages = [int(i_number) for i_number in ages_str.split()] #  а вот здесь уже добавляем цифры (через int) в список, как отдельные элементы
#
# for i_man in range(len(names_list)):
#     print(grats_template.format(name=names_list[i_man], age=ages[i_man])) # По длине списка в цикле присваиваем значения
#     # имени и возраста в grats_template
#
#
# people = [
#     ' '.join([names_list[i_man], str(ages[i_man])]) # Здесь соединяем имя и возраст в новом списке people. Так как мы
#     for i_man in range(len(names_list)) # соединяем списки, то и в скобах join указываем списки ([]) и обязательно список
#                                         # с цифрами переводим в сроку через str(), т.к. join  - это строчный метод
# ]
# people_str = ', '.join(people) # А здесь мы превращаем список people (который только что создали) в строку через ', '.join
# print('\nИменинники: ', people_str)

Задача 1. Заказ.Программа получает на вход имя и код заказа, а затем выводит на экран соответствующее сообщение
Метод: .format
# name = input('Имя: ')
# order = int(input('Номер заказа: '))
#
# print('Здравствуйте, {user_name} Ваш номер заказа: {order_num}. Приятного дня!'. format(
#     user_name=name,
#     order_num=order
# ))

Долги. В форматировании используются цифры в ключах (присвоение по порядку)
# name = input('Имя: ')
# debt = int(input('Введите долг: '))
#
# print('{0}! {0}, привет! Как дела, {0}? Где мои {1} рублей? {0}!'. format(name, debt))

Задача 3. IP-адрес
(на вход 4 числа и выводит на экран IP-адрес. Используйте переменную ip_address в качестве шаблона.)
# addres = []
#
# for i_num in range(4):
#     num = int(input(f'Введите {i_num + 1} число: ')) # Здесь используем f-string что бы не делать доп print и end=' '
#
#     if num < 0 or num > 255:
#         print('Ошибка. Такого IP адреса не существует')
#         print(('Введите число от 0 до 255 (включительно)'))
#     else:
#         addres.append(num)
#
# ip_address = '{}.{}.{}.{} '.format(addres[0], addres[1], addres[2], addres[3])
#
# print('IP адрес:', ip_address)

Методы split  и join
# text = input('Введите содержание текста: ')
# words_list = text.split() # Разделяет слова и удаляет лишние пробелы! Важно - работает только со строками
#
# print(words_list)
#
# new_text = '---'.join(words_list) # Наоборот соединяет слова из списка (можно указать,
# # что будет добавлено, указав это перед .join
#
# print(new_text)

Улучшенная лингвистика 2
У нас есть список из трёх слов, которые вводит пользователь. Затем вводится сам текст произведения. Программа считает кол-во
слов в тексте
# words, text = [input(f'Введите слово номер { i+1 }: ') for i in range(3)], input('Введите текст для поиска:')
# for word in words:
#     print(f'слово { word } встречается в тексте { text.count(word) } раз')

Удалить лишние пробелы
# text  = input('Введите текст: ').split() # Удаляет лишние пробелы по умолчанию
# r_text = ' '.join(text)
# print(r_text)

Путь к файлу 2
# user_name = input('Имя пользователя: ')
# file_name = input('Имя файла: ')
#
# path = 'C/{user}/docs/folder/{new_file}'.format( # Так присваиваем значения конкретному элементу
#     user=user_name,
#     new_file=file_name
# )
#
# if not path.startswith('C/'):          # Так проверяем с чего начинается строка (startswith)
#     print('Ошибка в названии диска')
# elif not path.endswith('.txt'):         # Так проверяем чем заканчивается строка (endswith)
#     print('Ошибка в расширении файла')
# else:
#     print('Путь к файлу:', path)

Верхний и нижний регистры. Методы меняют регистр всей строки/слова
# user_name = input('Имя пользователя: ').upper() # Делает регистр верхним
# user_name = input('Имя пользователя: ').lower() # Делает регистр нижним

На вход строка, из прописных и заглавных букв кириллицы. Код,проверяет, каких букв в строке больше, прописных или заглавных.
Если заглавных букв больше, то сделать все буквы строки заглавными, иначе сделать все прописными.
# text = input('Введите текст с заглавными и прописными: ')
#
# l = 0
# h = 0
# for char in text:
#     if char.islower():
#         l += 1
#     elif char.isupper():
#         h += 1
# if l > h:
#     print(text.lower())
# else:
#     print(text.upper())

Подстановки (placeholder) Используется в методе(.format)
# detal_num = 500000000
# price = 23.8589578
# increase = 0.045678
#
# print('На складе {:,d} деталей'.format(detal_num)) # В скобках ':' - объявляет placeholder, ',' - разделение числа на разряды по 3, 'd' - означает целое число
# print('Каждая деталь стоит {:.2f} рублей'.format(price)) # В скобках '.2' - округление до 2 символов, 'f' - означает вещественное число
# print('Цена увеличилась на {:.1%}'.format(increase)) # В скобках '.1' - округление до 1 символа, '%' - переводит в проценты
# можно так же указать экспоненту, для этого {:.0e}

Меню ресторана
На вход подаётся строка из названий блюд, разделённых символом «;», а на выходе эти названия перечисляются через запятую и пробел
# available = 'утиное филе;фланк-стейк;банановый пирог;плов'.split(';')
#
# print('На данный момент в меню есть :', ', '.join(available))


Задача 3. Файлы
Вводится название файла.В нем проверяется начало и расширение
# file_name = input('Название файла: ')
#
# if file_name.startswith(tuple('@№$%^&\*()')): # Если символов много используется кортеж (tuple), что бы проверить каждый символ
#     print('Ошибка: название начинается на один из специальных символов.')
# elif not file_name.endswith(tuple(['txt', 'docx'])): # В случае с расширениями, в кортеж каждое вносится через запятую в виде списка tuple(['x', 'y'])
#     print('Ошибка: неверное расширение файла. Ожидалось .txt или .docx.')
# else:
#     print('Файл назван верно.')

Заглавные буквы.  Программа изменяет регистр символов в строке так, чтобы первая буква каждого слова была заглавной, а остальные буквы — строчными
# string = input('Введите строку: ')
#
# print('Результат:', string.title())

Задача 5. Пароль
должен состоять минимум из восьми символов, в нём должны быть хотя бы одна большая буква и хотя бы три цифры.
Тогда он будет считаться надёжным
# def d_check (text):
#     t_check = [text[x] for x in range(len(text)) if text[x].isdigit()]
#     if len(t_check) >= 3:
#         return True
#     else:
#         return False
#
# while True:
#     password = (input('Придумайте пароль: '))           # Функция any() - ищет хотя бы одну заглавную букву в списке. Принцип представления для строк такой же как и для
#     if len(password) < 8 or not d_check(password) \     # списков, только скобки другие (). В них помещается цикл
#             or not any(x.isupper() for x in password):
#         print('Пароль ненадёжный. Попробуйте ещё раз.')
#     else:
#         print('Это надёжный пароль!')
#         break

Задача 6. Сжатие S = 'aaaabbсaa' преобразуется в 'a4b2с1a2', то есть группы одинаковых символов исходной строки заменяются
на этот символ и количество его повторений в этой позиции строки
# def compression(text):
#     count = 1
#     compressed_str = []
#     for sym in range(len(text)):
#         if text[sym] == text[sym +1:sym + 2]:
#             count += 1
#             continue                                 # здесь continue играет роль флага, то есть пока условие выполняется (текущий и следующий символ) ,счет в цикле продолжается (continue)
#         compressed_str.append(text[sym] + str(count))
#         count = 1                                     # Важно не забыть сбросить счетчик, после добавления результата в список
#     return compressed_str
#
# s = (input('Введите строку: '))
#
# print('Закодированная строка: {}'.format(''.join(compression(s))))

Задача 7. IP-адрес 2. Программа определяет, является ли заданная строка правильным IP-адресом.
Обеспечьте контроль ввода, где предусматривается ввод целых чисел от 0 до 255, а также точки между ними
# while True:
#     IP = input('Введите IP: ')
#     sep_ip = IP.split('.')
#
#     if len(sep_ip) < 4:
#         print('Адрес — это четыре числа, разделённые точками.')
#     else:
#         unit = 0
#         o_range = 0
#         for i in sep_ip:
#             if i.isdigit():
#                 unit += 1
#                 if int(i) > 255:
#                     o_range += 1
#                     print(f'{i} превышает 255.')
#             else:
#                 print(f'{i} — это не целое число.')
#         if unit == 4 and o_range == 0:
#             print('IP-адрес корректен.')
#             break
Задача 8. Бегущая строка
Пользователь вводит две строки. Напишите программу, которая определяет, можно ли первую строку получить из второй циклическим сдвигом
# str1 = input('Первая строка: ')
# str2 = input('Вторая строка: ')
#
# shift = 1
# chek = False
# for _ in range(len(str1) - 1):
#     str2 = str2[-1] + str2[:-1]
#     if str2 == str1:
#         chek = True
#         print(f'Первая строка получается из второй со сдвигом {shift}')
#         break
#     else:
#         shift += 1
# if not chek:
#     print('Первую строку нельзя получить из второй с помощью циклического сдвига.')

Задача 9. Сообщение. Пользователь вводит текст, состоящий из слов и знаков препинания. переворачивает (записывает в обратном порядке)
все слова текста, оставив знаки препинания без изменений
# text = input('Сообщение: ')
#
# new_text = ''
# i_start = 0
#
# for i in range(len(text)):
#     if not text[i].isalpha():
#         new_word = text[i_start:i]
#         new_text += new_word[::-1] + text[i]
#         i_start = i+1
#     elif text[i].isalpha() and i == len(text) - 1:
#         new_word = text[i_start:i]
#         new_text += new_word[::-1]
# print(new_text)

Задача 10. Истина - текст зашифрован шифром цезаря. Сдвиг равен индексу строки.
# def decryption(messenge):
#     translated = ''
#     for i_word in messenge:
#         if i_word in letters:
#             num_index = letters.find(i_word)
#             translated += letters[num_index - 1]
#         else:
#             translated += i_word
#     return translated
#
#
# def shift(text, key):
#     word_ln = len(text)
#     shift = key % word_ln
#     text = text[-shift:] + text[:-shift]
#     return text
#
#
# text = 'vujgvmCfb tj ufscfu ouib z/vhm jdjuFyqm jt fscfuu uibo jdju/jnqm fTjnqm tj scfuuf ibou fy/' \
#        'dpnqm yDpnqmf jt cfuufs boui dbufe/dpnqmj uGmb tj fuufsc ouib oftufe/ bstfTq jt uufscf uibo otf/' \
#        'ef uzSfbebcjmj vout/dp djbmTqf dbtft (ubsfo djbmtqf hifopv up csfbl ifu t/svmf ipvhiBmu zqsbdujdbmju fbutc uz/' \
#        'qvsj Fsspst tipvme wfsof qbtt foumz/tjm omfttV mjdjumzfyq odfe/tjmf Jo fui dfgb pg hvjuz-bncj gvtfsf fui ubujpoufnq up ftt/' \
#        'hv Uifsf vmetip fc pof.. boe sbcmzqsfgf zpom pof pvt..pcwj xbz pu pe ju/ ' \
#        'Bmuipvhi uibu bzx bzn puo cf wjpvtpc bu jstug ttvomf sfzpv( i/Evud xOp tj scfuuf ibou /' \
#        'ofwfs uipvhiBm fsofw jt fopgu cfuufs boui iu++sjh x/op gJ ifu nfoubujpojnqmf tj eibs pu mbjo-fyq tju( b bec /' \
#        'jefb Jg fui foubujpojnqmfn jt fbtz up bjo-fyqm ju znb cf b hppe jefb/ ' \
#        'bnftqbdftO bsf pof ipoljoh sfbuh efbj .. fu(tm pe psfn gp tf"uip'.split()
#
# letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
#
# text_2 = []
# key = 3
# for i_word in text:
#     text_decryption = decryption(i_word)
#     shift_text = shift(text_decryption, key)
#     if shift_text.endswith("/"):
#         key += 1
#         text_2.append(shift_text)
#     else:
#         text_2.append(shift_text)
#
# text_2 = ' '.join(text_2)
# text_2 = text_2.replace("+", "*")
# text_2 = text_2.replace("-", ",")
# text_2 = text_2.replace("(", "'")
# text_2 = text_2.replace("..", "--")
# text_2 = text_2.replace('"', "!")
# text_2 = text_2.replace("/", ".\n")
#
# print(text_2)

========================================================================================================================
Словари!
Инициализироватьс ловарь можно двумя способами:
1) phone _book = {}
2) phone _book = dict()
Словарь состоит из ключа и значения:
phone _book = {'Ваня': 89188886543} - где "Ваня" это ключ, номер телефона это значение. Ключ и значения разделены ":"
Ключи не могут быть словарями или списками. Ключи уникальны (не повторяются в одном словаре)
Что бы добавить данные в соварь:
phone_book['Имя'] = 'Алексей' - добавляем данные как в работе со списками (так же и обновляются значения, т.к. ключи уникальны)
Что бы вывести значение ключа:
print(phone_book['Имя'])

Сортировка словаря по значениям: "На месте" сортировать дневник нельзя, потому создаем новый (пустой) дневник
# player_list = {'qwerty': [95715, 0], 'Jack': [69485, 2],  'Alex': [95715, 1]}
# sorted_values = sorted(player_list.values)
# sorted_dict = {}

# for i in sorted_values: # Внешний цикл идет по значениям, так как сортируем по значениям
#     for k in player_list.keys():
#         if player_list[k] == i:
#             sorted_dict[k] = player_list[k]
#
# print(sorted_dict)

Сортировка словаря по ключам
# sorted_dict = {}
# nums = {1: 1, 3: 4, 2: 9}
#
# for i in sorted(nums):
#     sorted_dict[i] = nums[i]
#
# print(sorted_dict)
# print(sorted(nums.keys())) # Выводит отсортированные ключи
# print(sorted(nums.items())) # Вывродит отсортированные ключи и значения
# print(sorted(nums.values())) # Выводит отсортированные значения

Задача Студент
# student_str = input('Введите информацию о студенте через пробел\n'
#                     '(имя, фамилия, город, место учебы, оценки): '
# )
# student_info = student_str.split()
# student = dict()
# student['Имя'] = student_info[0]
# student['фамилия'] = student_info[1]
# student['город'] = student_info[2]
# student['Место учебы'] = student_info[3]
# student['оценки'] = [] # Т.к. кол-во оценок не известно, здесь просто добавим список и заполним его циклом
# for i_grade in student_info[4:]:  # Т.к. мы знаем, что оценки начинаются с 4го индекса, мы просто делаем срез в строке с [4]
#     student['оценки'].append(int(i_grade))
#
# for i_info in student:
#     print(i_info, '-', student[i_info]) # Зедсь выводи на печать через цикл ,что бы не печатать все в одну строку

На вход программе поступает целое число num. Программа создает словарь, который включает в себя ключи от 1 до num,
а значениями соответствующего ключа будет значение ключа в квадрате
# num = int(input('Введите целое число: '))
# num_dict = dict()
#
# for i_key in range(num):
#     num_dict[i_key + 1] = int(i_key + 1) ** 2
#
# print(num_dict)

Задача 3. Контакты. Программа запрашивает у пользователя имя контакта и номер телефона, добавляет их в словарь
и выводит на экран текущий словарь контактов. Если это имя уже есть в словаре, то выведите соответствующее сообщение
# phone_book = dict()
#
# while True:
#     if len(phone_book) < 1:
#         print('Текущие контакты на телефоне: \n<Пусто>')
#     else:
#         print('\nТекущие контакты на телефоне:')
#         for i_info in phone_book:                      # Итератор(i_info) печатает ключь словаря, а phone_book[i_info] - значение ключа
#             print(i_info, ' ', phone_book[i_info])
#
#     name = input('\nВведите имя контакта: ')
#
#     if name == 'end':
#         break
#     elif name not in phone_book:
#         phone_book[name] = int(input('Введите номер телефона: '))
#     else:
#         print('Ошибка: такое имя уже существует.')

Методы словарей:
Задача гистограмма частоты
# def histogram(string):
#     sym_dict = dict()
#     for sym in string:
#         if sym in sym_dict:
#             sym_dict[sym] += 1   # Здесь просто считаем уже существующий символ(ключ) в словаре
#         else:
#             sym_dict[sym] = 1    # А здесь добавляем в словарь символ(ключ), если его еще не было
#     return sym_dict
#
#
# text = input('Введите текст: ').lower()
# hist = histogram(text)
# print(hist)
#
# for i_sym in sorted(hist.keys()):        # метод .keys() отображает ключи, т.к. в словаре данные не упорядочены, сортировать их нельзя
#     print(i_sym, ':', hist[i_sym])       # мы просто берем список ключей и сортируем его (списки в отличии от словаря можно сортировать
#                                          # .sorted - сортирует ключи и выводит словарь в отсортированном виде
#
# print('Максимальная частота:', max(hist.values()))  # метод .vlues() отображает значения ключей
Задача phonebook
# phonebook = {
#     'Ваня': 100,
#     'Петя': 200,
#     'Алиса': 300
# }
#
# other_phonebook = {
#     'Игорь': 1000,
#     'Петя': 800,
#     'Алена': 2000
# }
#
# phonebook.update(other_phonebook) # Здесь в скобках .update() просто указываем другой словарь, и обновляем его
# print(phonebook)
# phonebook.pop('Игорь') # Метод.pop удаляет ключ и значение из словаря
# print(phonebook)
# phonebook['Варя'] = phonebook.pop('Алена') # Метод .pop заменяет ключ и оставляет значение (сначала указываем
#                                                          # на что меняем, а потом что именно требуется заменить
# print(phonebook)
# print(phonebook.get('Степан'))             # Метод .get() позволяет вернуть 'none' при попытке получить значение
#                                            # не существующего ключа и не ломает программу (не выдает ошибку)

Задача Магазин. объединяет оба словаря в один (в big_storage), затем запрашивает у пользователя название товара
и выводит на экран его количество. Если такого товара нет, то выводит об этом ошибку
# small_storage = {
#     'гвозди': 5000,
#     'шурупы': 3040,
#     'саморезы': 2000
# }
#
# big_storage = {
#     'доски': 1000,
#     'балки': 150,
#     'рейки': 600
# }
#
# big_storage.update(small_storage)
# goods = input('Введите название товара: ').lower()
#
# if not big_storage.get(goods):
#     print(f'Товара {goods} нет в ассортименте магазина')
# else:
#     print(f'Стоимость {goods} :', big_storage.get(goods))

Задача Кризис фруктов. Программа находит общий доход, затем выводит фрукт с минимальным доходом и удаляет его из словаря
# def get_key(val, p_list):         # Функция позволяет получить ключ по значению из словаря
#     for i_keys in p_list:           # Передаем в нее мин.цену и словарь
#         if p_list[i_keys] == val:   # Если значение ключа соответствует мин.сумме, возвращаем ключ
#             return i_keys
#
# incomes = {
#     'apple': 5600.20,
#     'orange': 3500.45,
#     'banana': 5000.00,
#     'bergamot': 3700.56,
#     'durian': 5987.23,
#     'grapefruit': 300.40,
#     'peach': 10000.50,
#     'pear': 1020.00,
#     'persimmon': 310.00,
# }
# lower_p = min(incomes.values()) # Получаем самую низкую цену
#
# print('Общий доход за год составил', sum(incomes.values()), 'рублей') # Тут просто суммируем значения словаря
# print('Самый маленький доход у', get_key(lower_p, incomes), '. Он составил:', lower_p)
# incomes.pop(get_key(lower_p, incomes)) # Удалям элемент словаря по полученному ключу из функции
# print('Итоговый словарь:', incomes)

Задача
Дана структура, которая содержит описание одного из членов семьи (имя, фамилия, хобби, сколько лет и дети)
реализует такую структуру: имя, фамилия, хобби, кол-во лет и дети. Затем, с помощью метода get и установки значения по умолчанию,
проверьте есть ли ребёнок с именем Bob. Затем в отдельную переменную получите фамилию этого ребёнка и выведите её на экран.
Если у него нет фамилии, то получите значение ‘Nosurname
# data = dict()  # Если планируем работать со словарем, нужно обязательно его создать
# data['family_member'] = {
#     "name": "Jane",
#     "surname": "Doe",
#     "hobbies": ["running", "sky diving", "singing"],
#     "age": 35,
#     "children": [
#         {
#             "name": "Alice",
#             "age": 6
#         },
#         {
#             "name": "Bob",
#             "age": 8,
#         }
#     ]
#     }
#
# print()
# for i_value in data.values():
#     for j_key in i_value:
#         print(j_key, i_value[j_key])
#
# name = data['family_member']['children'][1].get('name', 'No_name') # В скобках метода.get Указываем сначала ключ,
# а потом значение, которое нужно вывести, если такого ключа нет (значение по умолчанию)
# surname = data['family_member']['children'][1].get('surname', 'No_surname')
# print(name, surname)

Задача 2. Игроки. Есть готовый словарь игроков, у каждого игрока есть имя, команда, в которой он играет,
а также его текущий статус, в котором указано, отдыхает он, тренируется или путешествует:
# players_dict = {
#     1: {'name': 'Vanya', 'team': 'A', 'status': 'Rest'},
#     2: {'name': 'Lena', 'team': 'B', 'status': 'Training'},
#     3: {'name': 'Maxim', 'team': 'C', 'status': 'Travel'},
#     4: {'name': 'Egor', 'team': 'C', 'status': 'Rest'},
#     5: {'name': 'Andrei', 'team': 'A', 'status': 'Training'},
#     6: {'name': 'Sasha', 'team': 'A', 'status': 'Rest'},
#     7: {'name': 'Alina', 'team': 'B', 'status': 'Rest'},
#     8: {'name': 'Masha', 'team': 'C', 'status': 'Travel'}
# }
# player_A_members = [
#     player['name']
#     for player in players_dict.values()
#     if player['team'] == 'A' and player['status'] == 'Rest'
# ]
# player_B_members = [
#     player['name']
#     for player in players_dict.values()
#     if player['team'] == 'B' and player['status'] == 'Training'
# ]
# player_C_members = [
#     player['name']
#     for player in players_dict.values()
#     if player['team'] == 'C' and player['status'] == 'Travel'
# ]
#
# print('Все члены команды из команды А, которые отдыхают:', player_A_members)
# print('Все члены команды из команды B, которые тренируются:', player_B_members)
# print('Все члены команды из команды C, которые путешествуют:', player_C_members)

Множества
# numbers = [1, 2, 3, 2, 4, 5, 4, 6, 8, 9, 7]
# unicque = set(numbers) # .set похож на словарь, так же оформлен {}, но в нем только значения, без ключей. И они все так же уникальны
#                        # т.е. если нужно из двух множеств собрать уникальные значения исползум ф-ию .set
# numbers1 = {1, 2, 3, 4, 5}
# numbers2 = {4, 5, 6, 7, 8}
# numbers1.intersection(numbers2) # находит только пересечения во множествах
# nums1 = numbers1 & numbers2 # выполняет роль функции .intersection, называется амперсант
# numbers1.union(numbers2) # объеденяет множества (не дублируя уникальные значения
# nums = numbers1 | numbers2 # выполняет роль функции .union
# numbers1.difference(numbers2) # выводит только разницу во множествах
# nums = numbers1 - numbers2 # выполняет роль функции .difference (есть в первом но нет во втором)

Задача 2. Семинар. преобразует списки во множества и убирает повторяющиеся элементы. Затем удаляет минимальный элемент
из каждого множества и добавляет туда случайное число в диапазоне от 100 до 200. После три операции со множествами
# import random
#
# nums_1 = [29, 17, 10, 15, 13, 22, 12, 22, 7, 24, 26, 3, 11, 2, 3, 16, 19, 21, 2, 3, 8, 27, 2, 17, 2, 20, 12, 21, 3, 1]
# nums_2 = [16, 21, 30, 24, 5, 7, 23, 13, 11, 5, 21, 5, 19, 9, 12, 9, 15, 16, 29, 8, 16, 1, 22, 15, 16, 9, 1, 13, 21, 21]
#
# nums1 = set(nums_1)
# nums2 = set(nums_2)
#
# print('1-е множество:', nums1)
# print('2-е множество:', nums2)
#
# min_n1 = min(nums1)
# min_n2 = min(nums2)
#
# print('\nМинимальный элемент 1-го множества:', min_n1)
# print('Минимальный элемент 2-го множества:', min_n2)
#
# nums1.discard(min_n1)
# nums2.discard(min_n2)
#
# r_num1 = random.randint(100, 201)
# r_num2 = random.randint(100, 201)
#
# print('\nСлучайное число для 1-го множества:', r_num1)
# print('Случайное число для 2-го множества:', r_num2)
#
# nums1.add(r_num1)
# nums2.add(r_num2)
#
# print('\nОбъединение множеств:', nums1.union(nums2))
# print('Пересечение множеств:', nums1.intersection(nums2))
# print('Элементы, входящие в nums_2, но не входящие в nums_1:', nums2.difference(nums1))

Задача 3. Различные цифры. Программа находит все различные цифры в символьной строке
# string = input('Введите строку: ')
#
# l_string = [x for x in string if x.isdigit()]
# new_string = set(l_string)
#
# # Второй вариант решения
# # new_string = set()
# # for i_elem in string:
# #     if '0' <= i_elem <= '9':
# #         new_string.add(i_elem)
#
# print(new_string)

Представления словарей (dict comprehencion)
# data = [
#     {'ID': 10, 'user': 'Bob'},
#     {'ID': 11, 'user': 'Misha'},
#     {'ID': 12, 'user': 'Anton'},
#     {'ID': 10, 'user': 'Bob'},
#     {'ID': 11, 'user': 'Misha'},
# ]
# # Старый вариант. Двумя циклами по существующему списку
# unique_data = []
# for i_dict in data:
#     data_exist = False
#     for unic_dict in unique_data:
#         if unic_dict['ID'] == i_dict['ID']:
#             data_exist = True
#             break
#     if not data_exist:
#         unique_data.append(i_dict)
#
# print(unique_data, '\n')
#
# # А это представление, только словарей (как и со списками)
# unic_data_dict = {i_dict['ID']: i_dict for i_dict in data}
#
# print(unic_data_dict.values()) # .values() нужен что бы убрать значение ключей из вывода

Задача 1. Песни 2
запрашивает у пользователя количество песен из списка и названия этих песен, а на экран выводит общее время их звучания
# violator_songs = {
#     'World in My Eyes': 4.86,
#     'Sweetest Perfection': 4.43,
#     'Personal Jesus': 4.56,
#     'Halo': 4.9,
#     'Waiting for the Night': 6.07,
#     'Enjoy the Silence': 4.20,
#     'Policy of Truth': 4.76,
#     'Blue Dress': 4.29,
#     'Clean': 5.83
# }
#
# songs = int(input('Сколько песен выбрать? '))
# playlist = dict()
# for i_song in range(songs):
#     song = input(f'Название {i_song + 1}-ой песни: ')
#     playlist[song] = (violator_songs[song])
#
# print('Общее время звучания песен:', round(sum(playlist.values()), 2), 'минуты')

Задача 2. География. Пользователь вводит количество стран N, а затем N раз вводит страну и города, которые в этой стране
находятся, в одну строку. После пользователь вводит три названия городов. Реализуйте такую программу и для каждого из трёх
городов укажите, в какой стране он находится. Если такого города нет, то выведите соответствующее сообщение
# q_countrys = int(input('Количество стран: '))
# print('Введите через пробел\n'
#       '(Страна, первый город, второй город и т.д.)')
#
# print()
# country_dict = dict()
#
# for i_country in range(q_countrys):
#     country = input(f'{i_country + 1}-я страна: ').split()
#     for city in country[1:]:                               # Тут присваиваем каждому городу(город становится ключом, не наоборот!!)
#         country_dict[city] = country[0]                    # Значение - Страну (иначе потом придется города списком добавлять)
#
# for i_city in range(3):
#     city = input('\n{}-ый город: '.format(i_city + 1))
#     f_country = country_dict.get(city)
#     if f_country:
#         print(f'Город {city} расположен в стране {f_country}')
#     else:
#         print(f'По городу {city} данных нет.')

Задача 3. Криптовалюта. Все пункты задачи в принтах
# data = {
#     "address": "0x544444444444",
#     "ETH": {
#         "balance": 444,
#         "total_in": 444,
#         "total_out": 4
#     },
#     "count_txs": 2,
#     "tokens": [
#         {
#             "fst_token_info": {
#                 "address": "0x44444",
#                 "name": "fdf",
#                 "decimals": 0,
#                 "symbol": "dsfdsf",
#                 "total_supply": "3228562189",
#                 "owner": "0x44444",
#                 "last_updated": 1519022607901,
#                 "issuances_count": 0,
#                 "holders_count": 137528,
#                 "price": False
#             },
#             "balance": 5000,
#             "totalIn": 0,
#             "total_out": 0
#         },
#         {
#             "sec_token_info": {
#                 "address": "0x44444",
#                 "name": "ggg",
#                 "decimals": "2",
#                 "symbol": "fff",
#                 "total_supply": "250000000000",
#                 "owner": "0x44444",
#                 "last_updated": 1520452201,
#                 "issuances_count": 0,
#                 "holders_count": 20707,
#                 "price": False
#             },
#             "balance": 500,
#             "totalIn": 0,
#             "total_out": 0
#         }
#     ]
# }
#
# # 1
# print('\n1) ======Вывести списки ключей и значений словаря.======')
# for i in data:
#     print(f'{i}: {data.get(i)}')
#
# # 2
# print('\n2) ======В “ETH” добавить ключ “total_diff” со значением 100.======')
# data['ETH']['total_diff'] = 100
# print(f'ETH: {data["ETH"]}')
#
# # 3
# print('\n3) ======Внутри “fst_token_info” значение ключа “name” поменять с “fdf” на “doge”======:')
# data['tokens'][0]['fst_token_info']['name'] = 'doge'
# fst_name = data['tokens'][0]['fst_token_info']['name']
# print(f'fst_token_info-name: {fst_name}')
#
# # 4
# print('\n4) ======Удалить “total_out” из tokens и присвоить его значение в “total_out” внутри “ETH”.======:')
# data['ETH']['total_out'] = data['tokens'][1].pop('total_out')
# print(data['ETH'])
# print(data['tokens'][1])
#
# # 5
# print('\n5) ======Внутри "sec_token_info" изменить название ключа “price” на “total_price”=======:')
# data['tokens'][1]['sec_token_info']['total_price'] = data['tokens'][1]['sec_token_info'].pop('price')
# print(data['tokens'][1]['sec_token_info']['total_price'])

Задача 4. Товары.В базе данных магазина вся необходимая информация по товарам делится на два словаря:
первый отвечает за коды товаров, второй — за списки количества разнообразных товаров на складе:
Програма рассчитывает, на какую сумму лежит каждого товара на складе
# goods = {
#     'Лампа': '12345',
#     'Стол': '23456',
#     'Диван': '34567',
#     'Стул': '45678',
# }
#
# store = {
#     '12345': [
#         {'quantity': 27, 'price': 42},
#     ],
#     '23456': [
#         {'quantity': 22, 'price': 510},
#         {'quantity': 32, 'price': 520},
#     ],
#     '34567': [
#         {'quantity': 2, 'price': 1200},
#         {'quantity': 1, 'price': 1150},
#     ],
#     '45678': [
#         {'quantity': 50, 'price': 100},
#         {'quantity': 12, 'price': 95},
#         {'quantity': 43, 'price': 97},
#     ],
# }
#
# for i_goods in goods:
#     item_name = i_goods # Эта переменная нужна для принта в конце цикла
#     item_code = goods[i_goods]    # А эта для того что бы по ней идти во вложенном цикле вместо .keys (с методом не получится присваивать значения на прямую
#     item_quantity = 0
#     item_total_coast = 0
#     for j_goods in store[item_code]: # Здесь счетчик(j_goods) становится ключем словаря а 'in store[item_code]' - его значением
#         item_quantity += j_goods['quantity']
#         item_coast = j_goods['price']
#         item_total_coast += j_goods['price'] * j_goods['quantity']
#     print('{0} - {1} шт, общая стоимость {2} рублей'.format(item_name, item_quantity, item_total_coast))

Задача 5. Гистограмма частоты 2. Текст на вход и подсчет симвлов с выводом в виде таблицы + инвертированый словарь
меняем местами ключи и значения
# def table(text):
#     sim_dict = dict()
#     for i_sym in text:
#         if i_sym in sim_dict:
#             sim_dict[i_sym] += 1
#         else:
#             sim_dict[i_sym] = 1
#     return sim_dict
#
# def invert_dict(sym_dict):
#     new_dict = dict()
#     for k in sym_dict:
#         value, key = k, sym_dict[k] # Здесь с помощью переменных меняем ключи и значения местами. А дальше как в первой функции
#         if key in new_dict:
#             new_dict[key] += value
#         else:
#             new_dict[key] = value
#     return new_dict
#
# string = input('Введите текст: ')
# sym_table = table(string)
# r_dict = invert_dict(sym_table)
#
# print('Оригинальный словарь частот:')
# for i_table in sorted(sym_table.keys()):
#     print(i_table, ':', sym_table[i_table])
#
# print('\nИнвертированный словарь частот:')
# for i_dict in r_dict:
#     print(i_dict, ':', list(r_dict[i_dict])) # list нужен ,что бы все символы были в '', т.к. есть пробелы
# # И еще одно решение из инета, но там есть метод items(), но его еще не проходили (на всякий случай)
# text = input('Введите текст: ')
# sym_dict = dict()
# text_dict = dict()
#
# print('Оригинальный словарь частот:')
# for sym in text:
#     if
# sym in sym_dict:
# sym_dict[sym] += 1
# else:
# sym_dict[sym] = 1
# for i_sym in sorted(sym_dict.keys()):
#     print(i_sym, ': ', sym_dict[i_sym], sep='')
#
# print('Инвертированный словарь частот:')
# for i_letter, i_num in sym_dict.items():
#     text_dict.setdefault(i_num, []).append(i_letter)
# for i in text_dict:
#     print(i, ': ', text_dict[i], sep='')
# # Есть еще вариант, но он подходит только для уникальных значений - dict = {sim_dict[k]: k for k in sim_dict}

Задача 6. Словарь синонимов На вход в программу подаётся N пар слов. Каждое слово является синонимом к своему парному слову
затем запрашивает у пользователя слово и выводит на экран его синоним
# quantity = int(input('Введите количество пар слов: '))
# print('\nВведите пару через "-" ')
#
# pairs = dict()
# for i_pairs in range(quantity):                                      # если нужно будет обращаться и к ключам и к занчениям
#     pair = input(f'{i_pairs + 1}-я пара: ').split('-')               # проще завести 'двойной' словарь( в цикле двумя строками один и тот же элемент
#     pairs[pair[0].strip().capitalize()] = pair[1].strip().capitalize()  # делаем сначала ключом, потом значением
#     pairs[pair[1].strip().capitalize()] = pair[0].strip().capitalize()
#
#
# while True:
#     word = input('\nВведите слово: ').capitalize().strip()
#     if word == 'end':
#         break
#     elif word in pairs:
#         print('Синоним:', pairs.get(word))
#     else:
#         print('Такого слова в словаре нет.')

Задача 7. Пицца На вход в программу подаётся N заказов. Каждый заказ представляет собой строку вида
«Покупатель — название пиццы — количество заказанных пицц» Код выводит список покупателей и их заказов по алфавиту
# quantity = int(input('Введите количество заказов: '))
# print('\nВведите данные заказов через пробел (Фамилия пицца количество)')
#
# order_dict = dict()
# for i_order in range(quantity):
#     order = input(f'{i_order + 1}-й заказ: ').split()
#     if order[0] in order_dict:
#         if order[1] in order_dict[order[0]]:
#             order_dict[order[0]][order[1]] += int(order[2])
#         else:
#             order_dict[order[0]][order[1]] = int(order[2])
#     else:
#         order_dict[order[0]] = dict({order[1]: int(order[2])})
#
# print()
# for i_order in sorted(order_dict):
#     print(f'{i_order}: ')
#     for j_order in sorted(order_dict[i_order]):
#         print(f'        {j_order} : {order_dict[i_order][j_order]}')

Задача 8. Угадай число  Артём загадал натуральное число от 1 до N. Борис пытается угадать это число, для этого он
называет несколько чисел подряд. Артём говорит Борису «да», если среди названных Борисом чисел есть задуманное
Если попросить помощи, выведутся возможные числа (на использования методов множеств)
# max_num = int(input('Введите максимальное число: '))
# all_nums = set(range(1, max_num + 1))
# while True:
#     guess = input('Нужное число есть среди вот этих чисел: ')
#     if guess == 'Помогите!':
#         break
#     guess = {int(x) for x in guess.split()}
#     answer = input('Ответ Артёма: ').lower()
#     if answer == 'да':
#         all_nums &= guess
#     else:
#         all_nums -= guess
#
# print('Артём мог загадать следующие числа:', all_nums)

Задача 9. Родословная  генеалогическом древе у каждого человека, кроме родоначальника, есть ровно один родитель.
Каждому элементу дерева сопоставляется целое неотрицательное число, называемое высотой. У родоначальника высота равна 0,
у любого другого элемента высота на один больше, чем у его родителя Пргорамма определяет высоту всех его элементов дерева
# quantity = int(input('Введите количество человек: '))
# gen_tree_level = dict()
# descendant = dict()
#
# for i in range(1, quantity):
#     descendant_name, parent_name = input(f'{i}-я пара: ').split()
#     descendant[descendant_name] = parent_name
#     gen_tree_level[descendant_name] = 0
#     gen_tree_level[parent_name] = 0
#
# for i in descendant:
#     people = i #Тут берем переменную, что бы потом поменять ключ и значение
#     while people in descendant:
#         people = descendant[people] # тут как раз меняем ключ и значение (предка и родителя)
#         gen_tree_level[i] += 1 # Так как i осталась не изменной (предком), увеличиваем значение предка
#
# print('\n“Высота” каждого члена семьи:')
# for i in sorted(gen_tree_level):
#     print(i, gen_tree_level[i])

Задача 10. Снова палиндром Пользователь вводит строку. Необходимо написать программу, которая определяет, существует ли
у этой строки такая перестановка, при которой она станет палиндромом. Выведите соответствующее сообщение
# def polindrom(string):
#     sym_dict = {}
#     for i_sym in string:
#         sym_dict[i_sym] = sym_dict.get(i_sym, 0) + 1
#         # Идем по ключам дневника, и если символ не встретили, возвращаем 0
#         # и сразу прибавляем 1, так как только встретили его
#
#     odd_sym_count = 0
#     for i_value in sym_dict.values():
#         if i_value % 2 != 0:
#             odd_sym_count += 1
#
#     return odd_sym_count <= 1 # Возвращаем odd_sym_count только если он не больше 1
# # Для того, что бы получить палиндром, нужно, что бы нечетное количество символов встречалось
# # не больше одного раза
#
# text = input('Введите строку: ')
#
# if polindrom(text):
#     print('Можно сделать палиндромом.')
# else:
#     print('Нельзя сделать палиндромом.')
========================================================================================================================

Кортежи(tuple)!!!
Кортежи - это по сути списки (только скобки круглые), но с преимуществами:
1) Это не изменяемый тип данных! (в функции кортеж останется не изменным в отличии от списков)
2) Они работают быстрее и занимают меньше места в памяти
3) По ним(как и по спискам), так же можно брать срезы: tuple = (1, 2, 3, 4) - tuple[1] покажет 2
4) Что бы заполнить кортеж, можно даже не писать скобки: user = 'Vova', 'Petrov', 25
5) Полученному кортежу можно так же присваивать переменные, только проще: name, surname, age = user
6) В кортеже можно хранить другие кортежи или списки: some_tuple = (1, 2, 3, [1, 1, 1])
7) Если в кортеже хранится список (на самом деле храниться ссылка на список), то список можно изменить: some_tuple[3][0] = 100
8) Что бы превратить список в кортеж, достаточно написать: num_tuple = tuple(num_lis)
9) Котрежи можно объеденять с помощью простой конкотенации: tuple3 = tuple1 + tuple2

Задача 1. Создание кортежей

Заполните один кортеж десятью случайными целыми числами от 0 до 5 включительно. Также заполните второй кортеж числами
от −5 до 0. Объедините два кортежа, в третий. Выведите на экран третий кортеж и количество нулей в нём
# import random
#
# f_tuple = tuple([random.randint(0, 5) for x in range(10)])
# s_tuple = tuple([random.randint(-5, 0) for x in range(10)])
# t_tuple = s_tuple + f_tuple
#
# print('Первый кортеж', f_tuple)
# print('Второй кортеж', s_tuple)
# print('Третий кортеж', t_tuple)
# print('кол-во нулей в третьем кортеже:', t_tuple.count(0))

Задача 2. Цилиндр Пользователь вводит два значения: радиус и высоту. Напишите функцию для расчёта площади боковой
поверхности цилиндра и его полной площади. Функция должна возвращать два эти значения. После этого в основной программе
выводятся оба ответа в две строки
# import math
# def calc(hight, radius, yardage):
#     side = (math.pi * 2) * radius * hight
#     full = side + (2 * yardage)
#     return side, full
#
# h = int(input('Введите высоту: '))
# r = int(input('Введите радиус: '))
# s = math.pi * (r ** 2)
#
# print('Площадь боковой поверхности:', round(calc(h, r, s)[0], 2)) # Что бы вывести часть кортежа из функции используется срез [0]
# print('Полная площадь:', round(calc(h, r, s)[1], 2))

Задача 3. Неправильный код изначально есть кортеж из пяти чисел. Затем вызывается функция, которая получает на вход
кортеж чисел, генерирует случайный индекс и случайное значение, а затем по этим индексу и значению меняет сам кортеж.
Функция должна возвращать кортеж и случайное значение. Причём второй раз выводится сумма первого случайного значения и второго
# import random
#
# def change(nums):
#     nums = list(nums)
#     index = random.randint(0, 4)
#     value = random.randint(100, 1000)
#     nums[index] = value
#     nums = tuple(nums)
#     return nums, value
#
# my_nums = 1, 2, 3, 4, 5
#
# new_nums1 = change(my_nums)
# new_nums2 = change(my_nums)
# print(new_nums1[0], new_nums1[1])
# print(new_nums2[0], new_nums1[1] + new_nums2[1])

enumerate` - функция, которая генерирует кортежи из ИНДЕКСА и его ЗНАЧЕНИЯ в списках. Если нужно работать одновременно и
с индексом и со значением, в цикле принято использовать у enumerate. В цикле она перебирает одновременно индекс и значение
Для того что бы изменить значение, нужно напрямую (через индекс) к нему обратится. Так же работате со строками
# nums = [1, 2, 3, 4, 5]
# for i_nums, i_scores in enumerate(nums):
#     print(i_nums) # Отвечает за индекс элемента
#     print(i_scores) # Отвечает за значение элемента
#     nums[i_scores] += 10 # Обращение по индексу, что бы изменить значение в самом списке


Задача 1. Саботаж! Программа проходит по строке и выводит в консоль индексы символа '~'
# string = input('Строка: ')
#
# for index, char in enumerate(string):
#     if char == '~':
#         print(index, end=' ')

Задача 2. Словари из списков Создайте два списка, в каждом из которых лежит 10 случайных букв алфавита
(могут повторяться). Затем для каждого списка создайте словарь из пар «индекс — значение» и выведите оба словаря на экран
Буквы генерируем случайно
# import random
#
# def dict_maker(lists):
#     char_dict = dict()
#     for index, char in enumerate(lists):
#         char_dict[index] = char
#     return char_dict
#
# letters = ''.join(chr(x) for x in range(ord('а'), ord('я'))) # Генерируем алфавит с помощью ord() и chr()
# list1 = [random.choice(letters) for x in range(10)]
# list2 = [random.choice(letters) for x in range(10)]
#
# print('Первый словарь:', dict_maker(list1))
# print('Второй словарь:', dict_maker(list2))

Задача 3. Универсальная программа
Один заказчик попросил нас написать небольшой скрипт для своих криптографических нужд. При этом он заранее предупредил,
что скрипт должен уметь работать с любым итерируемым типом данных. Напишите функцию, которая возвращает список из
элементов итерируемого объекта (кортежа, строки, списка, словаря), у которых индекс чётный
isinstance(<элемент>, <тип данных>), которая возвращает True, если элемент принадлежит к этому типу данных,
и возвращает False в противном случае
# def check(data):
#     if isinstance(data, str):
#         new_string = ''
#         for index, sym in enumerate(data):
#             if index % 2 == 0:
#                 new_string += sym
#         return list(new_string)
#     elif isinstance(data, list):
#         new_list = []
#         for index, sym in enumerate(data):
#             if index % 2 == 0:
#                 new_list.append(sym)
#         return new_list
#     elif isinstance(data, dict):
#         new_dict = dict()
#         for index in data:
#             if index % 2 == 0:
#                 new_dict[index] = data[index]
#         return new_dict
#     elif isinstance(data, tuple):
#         new_tuple = ()
#         for index, sym in enumerate(data):
#             if index % 2 == 0:
#                 new_tuple =  new_tuple + (sym,) # Вот так добавляются данные в новый кортеж!! Обязательно со скобками и запятой в конце
#         return tuple(new_tuple)                 # Привычные += с кортежем не работают!!!!!!
#     elif isinstance(data, set):
#         new_set = {}
#         new_set = {sym for index, sym in enumerate(data) if index % 2 == 0}
#         return new_set
# #
# string1 = 'О Дивный Новый мир!'
# e_list = [100, 200, 300, 'буква', 0, 2, 'а']
# e_dict = {0: 100, 1: 200, 2: 300, 3: 'буква', 4: 0, 5: 2, 6: 'а'}
# e_tuple = (100, 200, 300, 'буква', 0, 2, 'а')
# e_set = {100, 200, 300, 'буква', 0, 2, 'а'}
#
#
# print('Результат строки:', check(string1))
# print('Результат списка:', check(e_list))
# print('Результат словаря:', check(e_dict))
# print('Результат кортежа:', check(e_tuple))
# print('Результат множества:', check(e_set))

.items()` - функция, которая генерирует кортежи из КЛЮЧА и его ЗНАЧЕНИЯ в словарях (не путать с индексом и значением в списке.
Если нужно работать одновременно и с КЛЮЧЕМ и со ЗНАЧЕНИЕМ, в цикле принято использовать .items() В цикле она перебирает
одновременно КЛЮЧ и ЗНАЧЕНИЯ Для того что бы изменить значение, нужно напрямую (через ключ) к нему обратится. Так же работате со строками

Задача Товары 2 (используется метод .items())
# goods = {
#     'Лампа': '12345',
#     'Стол': '23456',
#     'Диван': '34567',
#     'Стул': '45678',
# }
#
# store = {
#     '12345': [
#         {'quantity': 27, 'price': 42},
#     ],
#     '23456': [
#         {'quantity': 22, 'price': 510},
#         {'quantity': 32, 'price': 520},
#     ],
#     '34567': [
#         {'quantity': 2, 'price': 1200},
#         {'quantity': 1, 'price': 1150},
#     ],
#     '45678': [
#         {'quantity': 50, 'price': 100},
#         {'quantity': 12, 'price': 95},
#         {'quantity': 43, 'price': 97},
#     ],
# }
#
# for i_title, i_code in goods.items():
#     total_cuantity = 0
#     total_cost = 0
#     for j_godds in store[i_code]: # Вот тут прям указываем, по какому ключу в словаре идем (т.к. в нем есть внутренние словари)
#         total_cuantity += j_godds['quantity']
#         total_cost += j_godds['price'] * j_godds['quantity']
#     print('{title} - {quantity} шт, стоимость {cost} руб.'.format(
#         title=i_title,
#         quantity=total_cuantity,
#         cost=total_cost
#     ))

Задача 1. Кризис миновал. Вывести на экран словарь в следующем виде:(apple -- 5600.2). Не использовать обращение по ключу
# incomes = {
#     'apple': 5600.20,
#     'orange': 3500.45,
#     'banana': 5000.00,
#     'bergamot': 3700.56,
#     'durian': 5987.23,
#     'peach': 10000.50,
#     'pear': 1020.00,
#     'persimmon': 310.00,
# }
# for i_title, i_cost in incomes.items():
#     print('{title} -- {cost:,.2f}'.format(
#         title=i_title,
#         cost=i_cost
#     ))

адача 2. Сервер
У вас есть данные о сервере, которые хранятся в виде словаря: Нужно вывести красиво))
# server_data = {
#     "server": {
#         "host": "127.0.0.1",
#         "port": "10"
#     },
#     "configuration": {
#         "access": "true",
#         "login": "Ivan",
#         "password": "qwerty"
#     }
# }
# for i_server, i_configuration in server_data.items():
#     print(i_server)
#     for j_server in server_data[i_server]:
#         print('     {server} : {configuration}'.format(
#             server=j_server,
#             configuration=i_configuration[j_server]
#         ))

Задача 3. В одну строчку Нужно написать программу, которая выводит список тех значений, у которых ключ делится на 2.
Причём программа должна быть в одну строчку Дано не подходящее решение, т.к. в нем код повторяется - укорачиваем
print([{0: 0, 1: 100, 2: 144, 3: 20, 4: 19}[i_key] for i_key in {0: 0, 1: 100, 2: 144, 3: 20, 4: 19} if i_key % 2 == 0])
# print([i_value for i_key, i_value in {0: 0, 1: 100, 2: 144, 3: 20, 4: 19}.items() if i_key % 2 == 0])

Составные ключи - в словаре можно использоавть составной ключ, если он является кортежем!!!
А вот использовать ключ кортеэж для словаря со списком внутри НЕЛЬЗЯ!!! Питон не выделит ошибку, но при запуске выдаст ее

Задача 1. Паспортные данные В базе данных поликлиники хранятся паспортные данные людей. Хранение реализовано с помощью словаря
состоящего из пар «Серия и номер паспорта — фамилия и имя». Серия и номер — составной ключ, ФИО — составное значение.
по номеру и серии паспорта выдаёт имя и фамилию человека
# data = {
#     (5000, 123456): ('Иванов', 'Василий'),
#     (6000, 111111): ('Иванов', 'Петр'),
#     (7000, 222222): ('Медведев', 'Алексей'),
#     (8000, 333333): ('Алексеев', 'Георгий'),
#     (9000, 444444): ('Георгиева', 'Мария')
# }
# string = input('Введите серию и номер паспорта через пробел: ').split()
# series = tuple((int(string[0]), int(string[1]))) # Что бы загнать в кортеж разделленый текс в виде цифр, нужно обернуть в int каждый полученный элемент по индексу
# # print(series)
#
# for i_series in data:
#     if series == i_series:
#         print(data[i_series])
#
# ## Второй вариант (без цикла)
# print(data.get(series, 'Серия и номер отсутствуют в базе'))

Задача 2. Контакты 2 запрашивает у пользователя имя контакта, фамилию и номер телефона, добавляет их в словарь и выводит
на экран текущий словарь контактов. Словарь состоит из пар «Ф. И. — телефон», где Ф. И. — это составной ключ
# phone_book = dict()
#
# while True:
#     if len(phone_book) < 1:
#         print('Текущие контакты на телефоне: \n<Пусто>')
#     else:
#         print('\nТекущие контакты на телефоне:')
#         for i_name, i_number in phone_book.items():
#             print(i_name, ':', i_number)
#
#     name = input('\nВведите имя контакта: ').split()
#     name = tuple(name)
#
#     if name == 'end':
#         break
#     elif name not in phone_book:
#         phone_book[name] = int(input('Введите номер телефона: '))
#     else:
#         print('Ошибка: такое имя уже существует.')

функция zip - позволяет объеденить (кпаковать) несколько списков в один. Важно! упаковывает только элемны, если в списках
у них есть пары. Если пары нет - элемент отбрасывается. Что бы этого не происходило - нужен специальный модуль (нужно поискать)
# names = ['Tom', 'Bob', 'Albert']
# ages = [20, 45, 70]
#
# people = zip(names, ages) # Объединит в кортеж
# for i_people in people: # Печатаем циклом, т.к. это "ленивая генерация" и просто так не распечатает
#     print(i_people)
#
# people_list = list(zip(names, ages)) # Сделали писок с кортежами
# print((people_list))
#
# people_dict = dict(zip(names, ages)) # Сделали словарь
# print(people_dict)
#
# people_dict = dict(zip(names, people))
# for i_people, i_ages in people_dict.items():
#     print(i_people, i_ages)

# people_2 = {                                # А это comprehansions с функцией zip
#     i_name: i_ages + 10                     # i_name - ключ, i_ages - значение (ну и например мы хоти увеличить его на 10
#     for i_name, i_ages in zip(names, ages)
# }
# print(people_2)

Задача 1. Ревью кода
В задании был словарь из трёх студентов. Необходимо:
Вывести на экран список пар «ID студента — возраст».
Написать функцию, которая принимает в качестве аргумента словарь и возвращает два значения: полный список интересов всех
студентов и общую длину всех фамилий студентов. Код должен быть максимально Pythonic
# def data(dict):
#     hobby = []
#     l_surname = []
#     for i_key, i_value in dict.items():
#         hobby.extend(i_value.get('interests', ''))
#         l_surname += i_value.get('surname', '')
#     return set(hobby), len(l_surname), pair
#
# pair = [(i, students.get(i).get('age', 'Возраст не указан')) for i in students]
#
# print('\nСписок пар "ID студента — возраст":', pair)
# print('Полный список интересов всех студентов:', data(students)[0])
# print('Общая длина всех фамилий студентов:', data(students)[1])

## Ну и супер Pytonic код
# def data(dict):
#     result = (
#         set(sum([dict.get(i).get('interests') for i in range(1, len(dict) + 1)], [])),
#         [(i, dict.get(i).get('age')) for i in range(1, len(dict) + 1)],
#         sum([len(dict.get(i).get('surname')) for i in range(1, len(dict) + 1)])
#     )
#     f_print = (['Полный список интересов всех студентов:',
#                 'Список пар "ID студента — возраст":',
#                 'Общая длина всех фамилий студентов:'])
#     for i in range(len(f_print)):
#         print(f_print[i], result[i])
#
# data(students)

Задача 2. Универсальная программа 2 Функция возвращает список элементов итерируемого объекта (кортежа, строки, списка,
словаря), у которых индекс — это простое число. Для проверки на простое число напишите отдельную функцию is_prime
основная функция состояла только из оператора return и так же возвращала список
# def is_prime(i_num):
#     simple = True
#     if i_num > 1:
#         for divider in range(2, i_num):
#             if i_num % divider == 0:
#                 simple = False
#                 break
#         if simple:
#             return True
#         else:
#             return False
#     else:
#         return False
#
# def crypto(checking_sym):
#     return [v for i, v in enumerate(checking_sym) if is_prime(i)]
#
# # data = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
#
# print(crypto('О Дивный Новый мир!'))

Задача 3. Функция на вход принимает кортеж и какой-то случайный элемент (его можно вводить с клавиатуры).
Функция должна возвращать новый кортеж, начинающийся с первого появления элемента в нём и заканчивающийся вторым его
появлением включительно. Если элемента нет вовсе — вернуть пустой кортеж. Если элемент встречается только один раз —
вернуть кортеж, который начинается с этого элемента и идёт до конца исходного
# def slicer(s_tuple, s_number):
#     if s_number not in s_tuple:
#         return ()
#     if s_tuple.count(s_number) == 1:
#         return s_tuple[s_tuple.index(s_number):]
#     return s_tuple[s_tuple.index(s_number):s_tuple.index(s_number, s_tuple.index(s_number) + 1) + 1]
# # Здесь в срезе по индексу для начала и остановки дополнительный суппорт индекс(в нем как раз и указываем где стартовать и закнчивать)
# print(slicer((1, 2, 3, 4, 5, 6, 7, 8, 2, 2, 9, 10), int(input('Введите число: '))))

Задача 4. Игроки объединяет ключ словаря со значением в один кортеж, и выведите результат на экран
# players = {
#     ("Ivan", "Volkin"): (10, 5, 13),
#     ("Bob", "Robbin"): (7, 5, 14),
#     ("Rob", "Bobbin"): (12, 8, 2)
# }
#
# print([(i_keys + i_values) for i_keys, i_values in players.items()])

Задача 5. Одна семья апрашивает у пользователя фамилию и выводит на экран возраст всех членов одной семьи. Учтите, что,
например, у двух людей разного пола фамилии отличаются окончанием
# families = {
#     ("Сидоров", "Никита"): 3,
#     ("Сидорова", "Алина"): 34,
#     ("Сидоров", "Павел"): 10,
#     ("Иванов", " Александр"): 42,
#     ("Иванова", "Анастасия"): 38,
#     ("Иванова", "Елена"): 8,
#     ("Петров", "Евгений"): 28,
#     ("Петрова", "Екатерина"): 32,
#     ("Петрова", "Елизавета"): 12,
#     ("Петров", "Михаил"): 6,
# }
#
# surname = input('Введите фамилию: ').capitalize()
#
# for i_surname in families:
#     if i_surname[0].startswith(surname[:-1]):
#         print(*i_surname, families[i_surname]) # Ставим звездочку перед переменной, что бы распечатать словарь без скобок

# И альтернативное решение на всякий пожарный)))
# for i_surname in families:
#     if len(set(surname).difference(set(i_surname[0]))) <= 1:
#         print(*i_surname, families[i_surname])

Задача 6. По парам инициализирует список из 10 случайных целых чисел, а затем делит эти числа на пары кортежей
внутри списка. Выведите результат на экран
# import random
#
# original_list_1 = [random.randint(0, 10) for x in range(10)]
# print('\nОригинальный список:', original_list_1)
#
# new_list_1 = [(original_list_1[0 + x * 2], original_list_1[1 + x * 2])
#               for x in range(len(original_list_1) // 2)]
#
# print('Новый список 1:', new_list_1)
#
# ## Второй способ
#
# original_list = [random.randint(0, 10) for x in range(10)]
# print('\nОригинальный список:', original_list)
#
# zip_list = zip(original_list[::2], original_list[1::2])
# new_list_2 = []
# for pair in zip_list:
#     new_list_2.append(pair)
#
# print('Новый список 2:', new_list_2)

Задача 7. Функция сортировки Напишите функцию, которая сортирует по возрастанию кортеж, состоящий из целых чисел,
ивозвращает его отсортированным. Если хотя бы один элемент не является целым числом, то функция возвращает исходный кортеж
# def tpl_sort(some_tuple):
#     for i_elem in some_tuple:
#         if not isinstance(i_elem, int):
#             return some_tuple
#     return sorted(some_tuple) # Тут важно не делать блок else. Если его вставить, то вернется кортеж наполовину отсортированный
#
# print(tpl_sort((6, 3, -1.3, 8, 4, 10, -5)))

Задача 8. Контакты 3 Тоже что и контакты 2 + поиск по фамили и добавилось меню с выбором действия
# phone_book = {}
# def add_contact():
#     if len(phone_book) < 1:
#         print('Текущие контакты на телефоне: \n<Пусто>')
#     else:
#         print('\nТекущие контакты на телефоне:')
#         for i_name, i_number in phone_book.items():
#             print(i_name, ':', i_number)
#
#     name = input('\nВведите имя контакта через пробел: ').split()
#     name = tuple(name)
#
#     if name not in phone_book:
#         phone_book[name] = int(input('Введите номер телефона: '))
#     else:
#         print('\nОшибка: такое имя уже существует.')
#
# def find_contact():
#     surname = input('Введите фамилию: ').capitalize()
#     for i_surname in phone_book:
#         if i_surname[1].startswith(surname[:-1]):
#             print(*i_surname, phone_book[i_surname])
#
# while True:
#     print('\nВведите номер действия: ')
#     print('1. Добавить контакт', end='\n')
#     print('2. Найти человека')
#     print('3. Завершить программу')
#
#     action = int(input())
#     if action == 1:
#         add_contact()
#     elif action == 2:
#         find_contact()
#     elif action == 3:
#         print('Программа завершена')
#         break

Задача 9. Протокол соревнований Нужно отсортировать список победителей, сортировка делается с учетом того, кто раньше
набрал очки, если количество очков у претендентов одинковое
1) Решение  - с ключем в сортировке (спизжено из инета, ключи еще не проходили)
# def score_key(a):
#     return a[1][0] * 100000000 - a[1][1]
#
# player_list = {}
# rec_quantity = int(input('Сколько записей вносится в протокол? '))
# print('Введите через пробел результаты и имя игрока.'
#       ' Имя не должно содержать пробелов ')
# print('\nЗаписи (результат и имя):')
#
# for first in range(rec_quantity):
#     score, name = list(input(f'{first + 1}-я запись: ').split())
#     score = int(score)
#     if name in player_list:
#         if score > player_list[name][0]:
#             player_list[name][0] = score
#             player_list[name][1] = first
#     else:
#         player_list[name] = [score, first]
#
# score_list = list(player_list.items()) # Если сделать без items, то в список попадут только ключи (имена)
# score_list.sort(key=score_key, reverse=True) # revers=True для сортировки по убыванию. Если поставить False, будет сортировать по возрастанию
#
# print('Итоги соревнований:')
#
# for winners in 0, 1, 2: # Здесь прям указываем индексы, вместо диапазона, если нужно забрать из общего списка всего три элемента
#     print(f'{winners + 1} место. {score_list[winners][0]}', end=' ')
#     print(f'({score_list[winners][1][0]})', sep='')

2) Решение - помог куратор, оно попалов практическую работу
# def find_winners(players_scores):
#     best_results = players_scores
#     winners = dict()
#     place = 1
#
#     while place <= 3: # Таким образом определяем длину списка победителей
#         max_from_players = max((score_info[0]) for score_info in best_results.values()) # Тут смотрим максимум
#         pretendents = [[player, score_info]
#                        for player, score_info in best_results.items() if score_info[0] == max_from_players]
#
#         if len(pretendents) == 1: # Если максимум один, вносим его в список победителей
#             winners[place] = pretendents[0] # Вносим в список победителей
#             best_results.pop(pretendents[0][0]) # Удаляем из списка результатов, т.к. только внесли его в список победителей и он уже не нужен для сравнения
#             place += 1 # Увеличиваем место в списке победителей для следующего участника
#         else:
#             min_date_created = min([pretendent[1][1] for pretendent in pretendents]) # Если несколько одинаковых результатов, смотри на порядо очереди, когда получил очки
#             for pretendent in pretendents:
#                 if pretendent[1][1] == min_date_created: # Ищем порядок очереди в списке претендентов
#                     winners[place] = pretendent # Заносим найденного претендента в список победителей
#                     best_results.pop(pretendent[0]) # Удаляем из писка результатов, так как он уже в списке победителей
#                     break
#             place += 1
#     return winners
#
#
# player_list = {}
# rec_quantity = int(input('Сколько записей вносится в протокол? '))
# print('Введите через пробел результаты и имя игрока.'
#       ' Имя не должно содержать пробелов ')
# print('\nЗаписи (результат и имя):')
#
# for first in range(rec_quantity):
#     score, name = list(input(f'{first + 1}-я запись: ').split())
#     score = int(score)
#     if name in player_list:
#         if score > player_list[name][0]:
#             player_list[name][0] = score
#             player_list[name][1] = first
#     else:
#         player_list[name] = [score, first]
#
# winners = find_winners(player_list)
# print('\nИтоги соревнований:')
# for i_win in winners:
#     print(f'{i_win}-e место. {winners[i_win][0]}', end=' ')
#     print(f'({winners[i_win][1][0]})', sep='')

Задача 10. Своя функция zip аны строка и кортеж из чисел. Напишите программу, которая создаёт генератор из пар кортежей
«символ — число». Затем выведите на экран сам генератор и кортежи
# def min_range(some_data1, some_data2):
#     return min(len(some_data1), len(some_data2))
#
# def my_zip(some_data1, some_data2):
#     if isinstance(some_data1, dict) or isinstance(some_data2, dict):
#         return ((list(some_data1)[i_elem], list(some_data2)[i_elem])
#             for i_elem in range(min_range(some_data1, some_data2)))
#     else:
#         return ((some_data1[i_elem], some_data2[i_elem])
#             for i_elem in range(min_range(some_data1,some_data2)))
#
# data1 = 'abcde'
# data2 = {10: 2, 20: 3, 30: 4, 40: 5}
#
# print('Результат:')
# print(my_zip(data1, data2))
# for i_elem in my_zip(data1, data2):
#     print(i_elem)
========================================================================================================================
Рекурсия!!!
Максимальное ограничение почислу рекурсий в запросе - 995
Факториал с помощью рекурсии
# def factorial(num):
#     if num == 1: # Здесь задаем условие выхода из рекурсии, так как спускаться ниже 1 нет смысла (факторил 1 == 1)
#         return 1
#     fact_n_minus_1 = factorial(num - 1) # Т.к. 5! = (4 * 3 * 2 * 1), а 4! = (3 * 2 * 2 * 1) и т.д. Функция находит по порядку факториалы предыдущих чисел
#     return fact_n_minus_1 * num # Здесь функция умножает полученные ответы выше друг на друга
#
# num_fact = factorial(5)
# print(num_fact)

Возведение в степень без циклов и модуля .math Только рекурсия
# def power(a, n):
#     if n == 1: # Это является флагом для прирывания рекурсии
#         return a
#     result = power(a, n - 1) # Здесь n выполняет роль счетчика и позволяет выйти из рекурсии
#     return a * result
#
# float_num = float(input('Введите вещественное число: '))
# int_num = int(input('Введите степень числа: '))
#
# print(float_num, '**', int_num, '=', power(float_num, int_num))

Задача 3. Поиск элемента Ищем значения ключей в словаре (сруктуре) с помощью рекрсии
# site = {
#     'html': {
#         'head': {
#             'title': 'Мой сайт'
#         },
#         'body': {
#             'h2': 'Здесь будет мой заголовок',
#             'div': 'Тут, наверное, какой-то блок',
#             'p': 'А вот здесь новый абзац'
#         }
#     }
# }
# def find_key(some_dict, key):
#     if key in some_dict:
#         return some_dict[key]  # Если ключ оказался в самом начале, сразу возвращаем его
#
#     for sub_dict in some_dict.values():
#         if isinstance(sub_dict, dict): # А вот тут нужна проверка на тип данных, если значение окажется не словарем, вылетит ошибка
#             result = find_key(sub_dict, key) # Тут результат рекурсии присваиваем переменной
#             if result:
#                 break # И прирываем рекурсию, что бы не сделать ее бесконечной
#     else:
#         result = None
#
#     return result
#
# user_key = input('Искомый ключ: ')
#
# value = find_key(site, user_key)
# if value:
#     print(value)
# else:
#     print('Такого ключа в структуре сайта нет')

Задача 1. Ошибка Нужно сделать так, что бы переменные не менялись после работы функции (так как все они изменяемы тип)
Для этого просто передаем в функцию копии
# import random
#
# def change_dict(dct):
#     num = random.randint(1, 100)
#     for i_key, i_value in dct.items():
#         if isinstance(i_value, list):
#             i_value.append(num)
#         if isinstance(i_value, dict):
#             i_value[num] = i_key
#         if isinstance(i_value, set):
#             i_value.add(num)
#
# nums_list = [1, 2, 3]
# some_dict = {1: 'text', 2: 'another text'}
# uniq_nums = {1, 2, 3}
# common_dict = {1: nums_list[:], 2: some_dict.copy(), 3: uniq_nums.copy(), 4: (10, 20, 30)} # Здесь передаются копии
#
# change_dict(common_dict)
# print(common_dict)

Задача Непонятно. Функция получает данные, и возвращает тип данных (класс)б изменяемые они или нет + id объекта
# def data_is(some_data):
#     if isinstance(x, (str, int, float, tuple)):
#         print('Тип данных:', type(some_data))
#         print('Неизменяемый (immutable)')
#         print('Id объекта:', id(some_data))
#     else:
#         print('Тип данных:', type(some_data))
#         print('Изменяемый (mutable)')
#         print('Id объекта:', id(some_data))
#
# # data = input('Введите данные: ')
# x = {'a': 10, 'b': 20}
#
# data_is(x)

Именованные аргументы всегда следуют после позиционных (если наоборот -  выскочит ошибка)
Никакой аргумент не может быть передан боллее 1го раза: 'Записать файл'(это аргумент question) и тут же question='Перезаписать файл' - так же выбьет ошибку
# def ask_user(question, complaint='Не верный ввод! Пожалуйста введите да или нет',
#              retry=4): # Тут прописаны аргументы по умолчанию
#     while True:
#         answer = input(question).lower()
#         if answer == 'да':
#             return 1
#         if answer == 'нет':
#             return 0
#         retry -= 1
#         if retry == 0:
#             print('Количество попыток истекло!')
#             break
#         print(complaint)
#         print('Осталось попыток', retry)
#
# ask_user('\nВы действительно хотите выйти? ') # Вызов функции только с вопросом
# ask_user('\nУдалить файл? ', 'Так удалить или нет? ') # Вызов функции вопросом и сообщение об ошибке
# ask_user('\nЗаписать файл? ', retry=2) # Вызов функции с вопросом и количеством попыток. + тут retry - именованный аргумент

Задача 2. Накопление значений При работе со значениями по умолчанию и изменяемыми типами данных нужно знать и остерегаться
ещё одной интересной штуки
# def add_num(num, lst=None): # Если в функции не использовать None, а вместо этого использовать пустой список "[]"
#     if lst is None:         # То каждый раз значение по умолчанию будет принимать аргумент, который передавался в функцию
#         lst = []           # Т.е. список будет постоянно расти, хотя по умолчанию должен быть пустым!
#     lst.append(num)
#     return lst
#
#
# print(add_num(5))
# print(add_num(10))
# print(add_num(15))

Задача 3. Помощь другу - на вход принимает список всякого мусора. Если в списке встретился словарь, то оставляем его
Если в списке встретилась строка, то из неё нужно сделать словарь и положить его в итоговый список, например  “abc” → {“abc”: “abc”}
С числами нужно сделать то же самое, что и со строками. Всё остальное выкидываем из нашего списка
# def create_dict(some_data, template=None): # Не забываем про None в аргументе по умолчанию, для изменяемого типа данных
#     if isinstance(some_data, dict):
#         return some_data
#     if isinstance(some_data, list):
#         return None
#     if isinstance(some_data, set):
#         return None
#     if isinstance(some_data, int) or isinstance(some_data, float) or isinstance(some_data, str):
#         if template is None:
#             template = {}
#             template[some_data] = some_data
#         return template
#
#
# def data_preparation(old_list):
#     new_list = []
#     for i_element in old_list:
#         if create_dict(i_element) is None: # Тут проверяем, не являются ли данные из старого списка list или set
#             pass                           # Если являются, тупо ничего не делаем, для этого подходит заглушка pass
#         else:
#             new_list.append(create_dict(i_element)) # Если нет, то добавляем в наш новый список словари из функции create_dict
#     return new_list
#
# data = ['sad', {'ads': 23}, {43}, [12, 42, 1], 2323]
# new_data = data_preparation(data)
#
# print(new_data)

Задача Сумма налога. На вход сумма налога и неопределенное количество аргументов. Нужно посчитать сумму налога
И вывести доп аргументы. Важно! Нельзя злоупотреблять *args и **kwargs - иначе функция может вести себя непредсказуемо
Да и отлаживать такой код, в разы сложнее. Используем только если не знаем заранее кол-во аргументов (а не потому что лень)
# def print_tax_document(tax, *args, **kwargs): # *args - нужно ,когда не знаем, сколько аргументов попадет в функцию
#     price_sum = 0                           # **kwargs  - аналогично для именованных аршументов (передаются как словарь)
#     for i_price in args:
#         price_sum = price_sum + i_price * tax / 100
#     print('Сумма цен с учетом налога:', price_sum)
#
#     for i_info, i_value in kwargs.items():
#         print('{} : {}'.format(i_info, i_value))
#
#
#
# my_tax = int(input('Введите сумму налога: '))
# print_tax_document(my_tax, 1000, 950, 880, 920, 990, year=1997, doc_type='Report', operation_id=11102398)

Задача 1. Challenge 2 написать функцию, которая выводит все числа от 1 до num без использования циклов.(рекурсия)
# def func_cycle(number):
#     if number == 0:
#         return 1
#     func_cycle(number - 1)
#     print(number)
#
# num = int(input('Введите num: '))
#
# func_cycle(num)

Задача 2. Свой zip 2 Улучшеный zip. Работает со всеми типами данных (без проверки данных) Второе решение на неограниченное
Кол-во аргументов Используется map
# def my_zip(some_data1, some_data2):
#     tpl_list = [(tuple(some_data1)[i_elem], list(some_data2)[i_elem])
#         for i_elem in range(min(len(some_data1), len(some_data2)))]
#     return tpl_list
#
# data1 = 'abcde'
# data2 = {10: 2, 20: 3, 30: 4, 40: 5}
#
# print('Результат:')
# print(my_zip(data1, data2))
#
# ## Сначала написал как в задании, потом в чате увидел, что вроде как нужно на неограниченное количество аргументов
# ## Потому ниже код с *args (не знаю какой нужен, потому оставил оба)
#
# def my_zip(*args):
#     length = min(len(element) for element in args)
#     tpl_list = [tuple(i_elem[index] for i_elem in map(list, args))
#                 for index in range(length)]
#     return tpl_list
#
# data1 = 'abcde'
# data2 = {10: 2, 20: 3, 30: 4, 40: 5}
# data3 = {1: 's', 2: 'n', 3: 4}
#
# print('Результат:')
# print(my_zip(data1, data2, data3))
## Есть и третья версия ,с рекурсией, но в ней куча того ,что еще не проходили, типа Try, except, -> и прочих фишек
# def analog_zip_2(*args: iter, count=0, zip_list=[]) -> list[tuple]:
#     try:
#         zip_list.append(tuple(list(i)[count] for i in args))
#         analog_zip_2(*args, count=count + 1, zip_list=zip_list)
#     except IndexError:
#         return zip_list
#     return zip_list
#
# data1 = 'abcde'
# data2 = {10: 2, 20: 3, 30: 4, 40: 5}
# data3 = {1: 's', 2: 'n', 3: 4}
#
# analog_zip_2(data3, data2, data1)
# print(analog_zip_2(data3, data2, data1))

Задача 3. Ряд Фибоначчи Числа Фибоначчи — это ряд чисел, в котором каждое следующее число равно сумме двух предыдущих: 1, 1, 2, 3, 5, 8, 13…
Пользователь вводит num_pos. Напишите функцию, которая выводит число, стоящее на позиции num_pos в ряде Фибоначчи
# def pos_to_num(number): # Важно, так ак вето вызовов очень много, данная функция не эффективна для чисел фибоначчи
#     if number == 1:
#        return 1
#     if number == 2:
#         return 1
#     return pos_to_num(number - 1) + pos_to_num(number - 2)
# num_pos = int(input('Введите позицию числа в ряде Фибоначчи: '))
#
# print('Число:', pos_to_num(num_pos))

Полиндром с помощью рекурсии
# def polindrom(string):
#     if len(string) <= 1: # Т.к. один символ точно полиндром
#         return True
#     if string[0] != string[-1]: # если первый и последний символы не совпали, значит не полиндром
#         return False
#     return polindrom(string[1:-1]) # дальше просто срезаем первый и последний символы и рекурсивно проверяем
#
# string = input('Введите текст: ')
# if polindrom(string):
#     print('Строка является полиндромом')
# else:
#     print('Строка не является полиндромом')

Задача 4. Поиск элемента 2 Пользователь вводит искомый ключ. Если он хочет, то может ввести максимальную глубину —
уровень, до которого будет просматриваться структура
# site = {
# 	'html': {
# 		'head': {
# 			'title': 'Мой сайт'
# 		},
# 		'body': {
# 			'h2': 'Здесь будет мой заголовок',
# 			'div': 'Тут, наверное, какой-то блок',
# 			'p': 'А вот здесь новый абзац'
# 		}
# 	}
# }
#
# def find_key(data,some_key, some_depth=996):
#     while some_depth != 0:
#         if some_key in data:
#             return data[key]
#         for sub_data in data.values():
#             if isinstance(sub_data, dict):
#                 result = find_key(sub_data, some_key, some_depth - 1)
#                 if result:
#                     break
#         else:
#             result = None
#
#         return result
#
# key = input('\nВведите искомый ключ: ')
# question = input('Хотите ввести максимальную глубину? Y/N: ')
# if question == 'y'.lower():
#     depth = int(input('Введите максимальную глубину: '))
#     print('Значение ключа:', find_key(site, key, some_depth=depth))
# else:
#     print('Значение ключа:', find_key(site, key))

Задача 5. Ускоряем работу функции
Оптимизируйте функцию так, чтобы высчитывать факториал для одного и того же числа только один раз. Тут пользуемся багом
со значениями по умолчанию в фунции (засоваваем туда словарь, и он будет копить результаты расчетов) И дальше достаем
посчитанный факториал из посмтоянно формирующегося списка
# def calculating_math_func(data, factorials={1:1}):
#     print(sorted(factorials.items()))  # Проверка самого себя
#     if data in factorials:
#         result = factorials[data]
#     else:
#         result = max(factorials.values())
#         for index in range(max(factorials.keys()) + 1, data + 1):
#             result *= index
#             factorials[index] = result
#     result /= data ** 3
#     result = result ** 10
#     return result
#
# while True:
#     print(calculating_math_func(int(input('Введите число: '))))

Задача 6. Глубокое копирование запрашивает у клиента, сколько будет сайтов, а затем запрашивает название продукта и
после каждого запроса выводит на экран активные сайты (выполняем рекурсивный проход по сайту, меняем имя продукта)
# site = {
#     'html': {
#         'head': {
#             'title': 'Куплю/продам телефон недорого'
#         },
#         'body': {
#             'h2': 'У нас самая низкая цена на iphone',
#             'div': 'Купить',
#             'p': 'продать'
#         }
#     }
# }
#
# def structure(data, depth=1):
#     for i_keys, i_values in data.items():
#         if i_keys == 'title':
#             i_values = f'Куплю/продам {s_namae} недорого'
#         if i_keys == 'h2':
#             i_values = f'У нас самая низкая цена на {s_namae}'
#         if isinstance(i_values, dict):
#             print('       ' * depth, "'{}':".format(i_keys), '{')
#             structure(i_values, depth + 1)
#             print('       ' * depth, '}')
#         else:
#             print('        ' * depth, "'{}': '{}', ".format(i_keys, i_values))
#
# quantity = int(input('Сколько сайтов: '))
# for i_q in range(quantity):
#     s_namae = input('\nВведите название продукта для нового сайта: ')
#     print('Сайт для {}:'.format(s_namae))
#     print('site = {')
#     structure(site)
#     print('}')

Задача 7. Продвинутая функция sum, которая должна быть более гибкой, чем стандартная функция sum. Она должна уметь:
складывать числа из списка списков;складывать числа из набора параметров. Говоря иначе - должна работать с агрументами
типа *args (т.к. они передаются кортежем, есть особенности реализации суммирования, если в кортеже список списков)
# def sum(*args, result=0):
#     for i_elem in args:
#         if isinstance(i_elem, int):
#             result += i_elem
#         else:
#             for j_elem in i_elem:
#                 if isinstance(j_elem, int):
#                     result += j_elem
#                 else:
#                     result += sum(j_elem)
#     return result
#
# print(sum([[1, 2, [3]], [1], 3]))
# print(sum(1, 2, 3, 4, 5))

Задача 8. Список списков 2 Вы уже работали с многомерными списками и решали задачи, где с помощью list comprehensions
«выпрямляли» многомерные списки в один. Однако такой фокус не пройдёт, если у элементов разные уровни вложенности и этих
списков неограниченное количество. Пишем рекурсивную функцию для этого
# nice_list = [1, 2, [3, 4], [[5, 6, 7], [8, 9, 10]],
#              [[11, 12, 13], [14, 15], [16, 17, 18]]]
#
# def flatten(some_data, answer=None):
#     if answer == None:
#         answer = []
#     for i_elem in some_data:
#         if not isinstance(i_elem, list):
#             answer.append(i_elem)
#         else:
#             answer.extend(flatten(i_elem)) # Вот тут важно! Если мы провалились в след. список, то ответ расширяем (extend), а не append!!!!
#     return answer
#
# print('\nОтвет:', flatten(nice_list))

Задача 9. Ханойские башни
Фишка решения - переложить на промежуточный стержень, на одно кольцо меньше общего кол-ва колец (n - 1)
# def move(n, x, y):
#     if n <= 0: return
#     second_rod = 6 - x - y      # (Находим номер промежуточного стерженя.Что бы его найти, нужно
#                                 # Из суммы номеров (1, 2 и 3го стержня) т.е. 1+2+3 = 6
#                                 # вычесть перый (х) и третий (y)
#     move(n-1, x, second_rod)
#     print('Переложить диск', n, 'со стержня номер', x,  'на стержень номер', y)
#     move(n-1, second_rod, y)
#
# quantity = int(input('Введите количество дисков: '))
# move(quantity, 1, 3)

========================================================================================================================
Работа с ОС.
Генерация путей (модуль .path - нужен именно для генерации!!!!)
# import os # OS - модуль для работы с ОС соответсвенно))
## abspath - по умолчанию идет от корня системы
## os.path.join - используется для генерации путей относительных (то есть путь относительно той папки, в которой находимся)
# print(os.path.abspath('new_folder')) # Сгененрировать абсолютный путь к папке (используем модуль .abspth() )
# print(os.path.abspath('../new_folder')) # Подняться на одну папку выше (с помощью " ../ ") - сработатет только у нас на компе
# print(os.path.abspath(os.path.join('..', 'new_folder'))) # Подняться на одну папку выше (с помощью " .join ") - сработатет на любом компе
# print(os.path.abspath('/new_folder')) # Положить папку в корень диска С (с помощью " / ") - сработатет только у нас на компе
# print(os.path.abspath(os.path.join(os.path.sep, 'new_folder' ))) # Положить папку в корень диска С (с помощью модуля .sep (то же что и слэш)) - сработатет на любом компе

Перебор элементов из списка в указанной директории
# import os
#
# projects_list = ['X-mas', 'PycharmProjects', 'Saved games']
#
# def print_dir(project):
#     print('\nСодержимое директории', project)
#     if os.path.exists(project): # Проверяем, существует ли в списке указанный путь
#         for i_elem in os.listdir(project): # цикл нужен, что бы пройтись по директории с помощью модуля os.listdir
#             path = os.path.join(project, i_elem) # формируем пути из переменных project и i_elem
#             print('    ', path)
#     else:
#         print('Указанного каталога не существует')
#
# for i_project in projects_list:
#     path_to_project = os.path.abspath(os.path.join('..',  '..', i_project)) # точки('..') нужны что бы указать уровень вложенности нашего списка папок
#     print_dir(path_to_project) # В эту ф-ю передадим наши пути

Задача 1. Сисадмин Если нужен путь до этого файла, причём как относительный, так и абсолютный
# import os
#
# folder_name = 'acces'
# file_name = 'admin.bat'
#
# abs_bath = os.path.abspath(os.path.join(folder_name, file_name))
# rel_path = os.path.join('Test area', folder_name, file_name)
#
# print('\nАбсолютный путь до файла:', abs_bath)
# print('Относительный путь до файла:', rel_path)

Задача 2. Содержимое выберите любую директорию на своём диске и затем напишите программу, выводящую на экран абсолютные
пути к файлам и папкам, которые находятся внутри этой директории
# import os
#
# def print_dir(project):
#     for i_elem in os.listdir(project):
#         path = os.path.join(project, i_elem)
#         print(path)
#
# p_project = 'Python_Basic'
# path_to_project = os.path.abspath(os.path.join('..', p_project, p_project))
# print_dir(path_to_project)

Поиск файла по названию  в каталогах папок ОС
# import os
# def find_file(cur_path, file_name):
#     print('Переходим', cur_path)
#     for i_elem in os.listdir(cur_path):
#         path = os.path.join(cur_path, i_elem)
#         print('Смотрим', path)
#         if file_name == i_elem:
#             return path
#         if os.path.isdir(path):
#             print('Это директория')
#             result = find_file(path, i_elem)
#             if result:
#                 break
#     else:
#         result = None
#     return result
#
# file_path = find_file(os.path.abspath
#                       (os.path.join('..', '..', 'Saved Games')),
#                       'm3_05_winter.player')
# if file_path:
#     print('Абсолютный путь к файлу:', file_path)
#     print('Размер файла:', os.path.getsize(file_path), 'байт') # Возвращаем размер файла
# else:`
#     print('Файл не найден')

Задача 1. Иконки по заданному абсолютному пути определяет, на что указывает этот путь (на директорию, файл, или же путь
является ссылкой), и выведите соответствующее сообщение. Если путь указывает на файл, то также выведите его размер
(сколько он весит в байтах). Обеспечьте контроль ввода: проверка пути на существование
# path_to_file = r"C:\Users\notf8\Saved Games\m3_07_yamantau.player" # Нужно ставить 'r' в начале строки, что бы питон
# # не читал \notf8 - как литерал \n
#
# if os.path.exists(path_to_file):
#     print('\nПуть:', path_to_file)
#     if os.path.isfile(path_to_file):
#         print('Это файл')
#         print('Размер файла:', os.path.getsize(path_to_file), 'Байт')
#     elif os.path.isdir(path_to_file):
#         print('Это папка')
#         print('Размер папки:', os.path.getsize(path_to_file), 'Байт')
#     elif os.path.islink(path_to_file):
#         print('Это ссылка')
# else:
#     print('Указанного пути не существует')

Задача 2. Поиск файла В уроке мы написали функцию, которая ищет нужный нам файл во всех подкаталогах указанной директории
Однако, как мы понимаем, файлов с таким названием может быть несколько
В этом задании print внутири функции
# import os
# def find_file(cur_path, file):
#     for i_elem in os.listdir(cur_path):
#         path = os.path.join(cur_path, i_elem)
#         if file == i_elem:
#             print(path)
#         if os.path.isdir(path):
#             find_file(path, file)
#
# file_path = r"C:\Users\notf8\PycharmProjects\Python_Basic\Python_Basic"
# file_name = 'main.py'
#
# print('Найдены следующие пути:')
# find_file(file_path, file_name)
========================================================================================================================
Работа с файлами:
Чтение:
1)  Обязательно закрываем файл (file.close()) работы с ним, иначе другая часть кода не сможет открыть его,
точнее, придется отдельной строкой открывать его заново (открыть второй поток)
2) Текстовые файлы - итераторы, т.е. его можно читать циклом без методов .open Но при чтении будет добавляться устая
строка между строками (в конце каждоой строки в txt стоит литерал \n), потому надо настраивать принт (end='')
Потому с тхт лучше работать с циклом (т.к. может быть слишком большим)
speakers_file = open('speakers.txt', 'r', encoding='utf-8') # 1-указали файл, 2-'r'значит read, 3 - тип кодировки (для кирилицы)
data = speakers_file.read()
print(data)
или
speakers_file.close()
for i_line in speakers_file:
    print(i_line, end='')

Задача 1. Результаты
На экран нужно было вывести сумму очков первой группы, затем разность очков опять же первой группы и напоследок —
произведение очков уже второй группы
# file = open(r"C:\Users\notf8\Desktop\task\group_1.txt", 'r', encoding='utf-8')
# summa = 0
# diff = 0
# for i_line in file:
#     info = i_line.split()
#     summa += int(info[2])
#     diff -= int(info[2])
#
# print('Сумма очков первой группы:', summa)
# print('Разность очков первой группы:', diff)
# file.close()
#
# file_2 = open(r"C:\Users\notf8\Desktop\task\Additional_info\group_2.txt", 'r', encoding='utf-8')
# compose = 1
# for i_line in file_2:
#     info = i_line.split()
#     compose *= int(info[2])
#
# print('Произведение очков второй группы:', compose)
# file_2.close()

Задача 2. Поиск файла 2
Используя функцию поиска файла из предыдущего урока, реализуйте программу, которая находит внутри указанного пути все
файлы с искомым названием и выводит на экран текст одного из них (выбор можно сгенерировать случайно)
Подсказка: можно использовать, например, список для сохранения найденного пути
# import random
# import os
# def find_file(cur_path, file, path_list=None):
#     if path_list == None:
#         path_list = []
#     for i_elem in os.listdir(cur_path):
#         path = os.path.join(cur_path, i_elem)
#         if file == i_elem:
#             path_list.append(path)
#         if os.path.isdir(path):
#             result = find_file(path, file)
#             path_list.extend(result)
#     return path_list
#
# file_path = r"C:\Users\notf8\PycharmProjects\Python_Basic\Python_Basic"
# file_name = 'main.py'
#
# print('Найдены следующие пути:')
# if find_file(file_path, file_name):
#     for i_list in find_file(file_path, file_name):
#         print(i_list)
# else:
#     print('<Указанные файлы отсутствуют в каталоге>')
#
# print('\nРандомно выбранный файл:')
# if find_file(file_path, file_name):
#     file = open(find_file(file_path, file_name)
#                 [random.randint(0, len(find_file(file_path, file_name)))],
#                 'r', encoding='utf-8')
#     data = file.read()
#     print(data)
#     file.close()
# else:
#     print('<Файлы отсутствуют>')